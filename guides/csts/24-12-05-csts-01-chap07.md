제 7 장 테스트 자동화 
7.1 개 요
테스트 자동화란 도구를 사용하여 테스트 프로세스의 일부 혹은 전부를 자동화하는 것을
의미한다. 사람이 수행하는 단순하고 반복적인 일에 도구를 사용하여 효율적으로 작업을
수행할 수 있게 하고, 테스터의 부담을 줄여 좀 더 창의적인 작업에 집중할 수 있게 한다.
표 7.1은 테스트를 지원하는 업무에 따라 도구를 분류한 것이다.

![표 7.1 도구 분류](ct7.1.png)

현재 개발 중인 웹 사이트의 로그인 기능이 올바르게 동작하는지 테스트하기 위해 그림
7.1의 단계들을 수행해야 하는 상황을 가정해보자. 만약 이 단계들을 수작업으로 수행해야
한다면 굉장히 단순한 작업인데도 수작업으로 많은 실수가 발생할 가능성이 있다. 웹 사이
트 주소나 아이디, 또는 비번을 잘못 입력할 수 있고, 주어진 절차를 빠뜨리거나 따르지 않
으면 올바른 테스트를 수행할 수 없게 된다. 또한, 로그인 기능이 올바르게 동작하는지 확
인하기 위해 웰컴 페이지를 사람이 직접 확인해야 한다.
1. 웹 사이트 주소 입력
2. ld 필드에 가입한 아이디 입력
3. 패스워드 필드에 비번 입력
4. 로그인 버튼 클릭
5. 웰컴(welcome) 페이지 확인
그림 7.1 로그인 검증을 위한 테스트 단계

--

그림 7.2는 그림 7.1을 셀레늄(Selenium)의 JUnit Webdriver 코드로 변환한 것이다. 셀
레늄은 웹 애플리케이션 테스트를 위한 프레임워크이며 Java, C#, PHP, Ruby 등 많은 언
어를 지원한다. IE, Chrome, Firefox 등 대부분의 브라우저 및 윈도우와 리눅스 등 많은
플랫폼에서 실행이 가능하다.

```java
@Test
public void shouldVisitWelcomePage() throws IOException {
driver.get(“웹 사이트 주소”);
driver.findElement(By.id(“id”)).sendKeys(“아이디 ”);
driver.findElement(By.id(“pwd”)).sendKeys(“비번 ”);
driver.findElement(By.id(“btnsignIn”)).click();
assertEquals(“웰컴 메시지”,driver”.findElement(By.xpath(“blah blah”)).getText())
}
```

그림 7.2 JUnit Webdriver 코드 변환

이와 같이 도구를 사용하여 실행할 수 있도록 자동화하면 테스터는 단순하면서 반복적인 업
무에서 벗어나 일관성을 유지하면서 빠르게 테스트를 수행할 수 있다. 성능 테스트, 부하 테
스트, 스트레스 테스트 등과 같이 실제 자동화하지 않으면 효과적인 테스트를 할 수 없는 분
야가 있다. 예를 들어, 부하 테스트나 스트레스 테스트를 위해 100명의 사용자가 동시에 시
스템에 접근해야 하는 경우에 100명의 사용자를 실제 고용해서 테스트를 수행한다면 시간
과 비용이 너무 많이 들 것이고, 사용자들이 테스트 목적을 위해 정확하게 테스트를 수행한다는
것을 보장하기는 매우 어려울 것이다. 반면에 주어진 테스트 스크립트를 100개의 쓰레
드나 프로세스를 이용하여 자동으로 수행한다면 훨씬 효과적으로 테스트를 수행할 수 있다.
물론, 모든 경우에 테스트 작업을 자동화하는 것이 정답은 아니다. 예를 들어, 자주 반복적
으로 수행되는 테스트가 아니고 한두 번 수행되는 경우에는 굳이 테스트를 자동화할 필요
가 없을 것이다. 또한, 경우에 따라서는 자동화된 테스트보다 매뉴얼 테스트(Manual test)
가 효과적일 때도 있다. 예를 들면, 사용자 인터페이스 테스트를 수행할 때 화면 배경 색상
과 버튼 배경 색상이 동일하여 버튼을 구분하기 어렵거나 화면 전환이 부자연스러운 경우
는 사람이 화면을 지켜보고 있을 때 쉽게 발견할 수 있을 것이다.

--
7.2 테스트 자동화 분야 및 테스트 도구
전통적인 테스트 자동화에서는 테스트 케이스의 실행을 자동으로 하는 자동화를 핵심요소
로 간주하기 쉬운데, 완성도 높은 자동화 인프라는 테스트의 여러 단계에 걸쳐 전체적인 테
스트 활동의 전문성과 안정성에 관여한다. 이런 자동화 모델의 예로 키스 스토비(Keith
Stobie)와 마크 버그먼(Mark Bergman)의 SEARCH 모델이 있다.

SEARCH 모델에서 테스트 자동화는 셋업(Set up), 실행(Execution), 분석(Analysis),
보고(Report), 정리(Clean up), 도움말(Help) 의 총 6단계로 구성된다.
화함으로써 효율을 높이고 사람의 실수
각 단계를 자동
(Human error)를 예방할 수 있으며,
문성과 일관성을 가진 테스트를 할 수 있다
이를 통해 전문성과 일관성을 가진 테스트를 할 수 있다.

ISO/IEC/IEEE 29119는 테스트 프로세스를 조직 테스트 프로세스, 테스트 관리 프로세스
및 동적 테스트 프로세스로 분류하였으며, 이들 테스트 프로세스에 관련된 활동들은 모두
자동화 대상이 될 수 있다. 이번 절에서는 ISO/IEC/IEEE 29119의 동적 테스트 프로세스
활동을 지원하는 도구에 대해 살펴본다.

![그림 7.3 ISO/IEC/IEEE 29119 동적 테스트 프로세스](c7.3.png)

--

제7장 테스트 자동화 127
테스트 설계 도구는 기대 결과도 생성한다. 예를 들어, EvoSuite는 유전자 알고리즘(GA,
Genetic Algorithm)에 바탕을 두고 소스 코드를 분석하여 테스트 케이스를 생성한다.
EvoSuite는 기대 결과를 생성하기 위해 명세 정보를 활용하지 않고, 실제 프로그램을 실행
하여 실행 결과를 기대 결과로 대신하는 방식을 취한다.
이러한 도구는 레거시 시스템을 기반으로 프로젝트를 진행할 때 이렇게 생성된 테스트 케
이스들을 리그레션 테스트 케이스로 활용할 수 있다. 예를 들어, 레거시 시스템에 새로운
기능을 추가하기 위해서 시스템을 변경할 때, 기존의 기능이 영향을 받았는지 테스트하기
위해 실행 결과를 기대 결과로 대신하는 테스트 케이스들을 실행할 수 있다.
7.2.2 테스트 환경 구축 도구
테스트 환경 구축은 테스트를 원활하게 수행하기 위한 가장 기본적이면서 중요한 작업이다.
개발자 환경에서 작동이 되는 애플리케이션이 실제 테스트 환경이나 운영 환경에서는 작동이
되지 않는 경우가 있다. 이렇게 일관성 없이 애플리케이션이 실행되는 이유는 매우 다양하다.
운영 및 테스트 환경 설정이 개발 환경과 다르거나 사용하는 라이브러리 버전이 다를 수도 있
다. 그뿐만 아니라 애플리케이션 환경을 설정하는 작업은 대부분 매우 까다롭기 때문에 환경
을 구축하는 동안 실수를 하거나 구성 단계를 누락하기도 하고 순서를 지키지 않을 수도 있다.
최근에 IaC(Infrastructure as Code) 개념이 등장하였다. IaC는 말 그대로 “인프라를 코드
화한다”, “인프라를 코드로 기록한다”의 의미이다. 즉, IaC를 통해 시스템 환경을 수동으로
구성하는 대신 시스템 환경 구성 정보를 기록한 스크립트를 사용하여 자동으로 인프라를 구
성한다. 이와 같이 인프라 구성 정보를 코드로 관리해두면 애플리케이션 개발 시 Git 등과 같
은 버전 관리 도구로 소스 코드를 관리하는 것처럼 변경 이력을 일원화하여 관리할 수 있다.
IaC 개념을 바탕으로 한 도커(Docker)는 애플리케이션 실행 환경을 자동으로 설치할 수
있는 도구이다. 도커는 소프트웨어 컨테이너(Container)라는 단위로 패키징하며, 이 컨테
이너에는 라이브러리, 미들웨어, 시스템 도구, 런타임 환경 등 애플리케이션을 실행하는
데 필요한 모든 것을 포함할 수 있다. 이러한 애플리케이션 실행 환경을 도커에서는
“Dockerfile”이라는 소스 코드로 환경 구성 정보를 기록하여 관리한다. 따라서 애플리케
이션을 신속하게 배포 및 확장할 수 있으며 코드가 문제없이 개발자 플랫폼에 구애받지 않
고 실행될 것임을 확신할 수 있다. 즉, 누구라도 구성파일 실행을 통해 테스트 환경이나 운
영 환경을 아주 손쉽게 구축할 수 있다.

--

7.2.3 테스트 실행 도구
테스트 실행은 가장 전통적인 테스트 자동화의 핵심 분야이다. 테스트 실행 도구는 테스트 케이스
를 자동으로 실행할 수 있도록 스크립트로 변환하여 실행한다. 테스트 케이스를 컴퓨터가 실행할
수 있는 스크립트로 변환하는 방법 중에서 대표적인 것이 Record&Playback 방식이다.
이 방식을 지원하는 도구는 사용자가 브라우저 등을 통해 시스템을 사용하는 행위와 시스
템 반응을 스크립트로 기록하고 이를 다시 반복 실행할 수 있도록 한다. 따라서 도구 사용
자가 테스트 스크립트 언어에 관한 특별한 지식이 없어도 테스트 케이스를 설계하여 실행
할 수 있다.

![그림 7.4 사용자의 행위를 기록](c7.4.png)

Katalon Studio는 Record&Playback 기능을 제공하는 도구이다. Katalon Studio는 크
롬 브라우저의 플러그인으로 제공되며 기존의 Selenium IDE의 기능을 제공한다. 그림
7.4는 사용자가 네이버에서 한성대학교 홈페이지를 찾아가는 과정을 보여준다. Katalon
Studio는 이러한 사용자의 행위를 그림 7.5와 같은 스크립트로 저장하고 사용자의 관여 없
이 다시 실행할 수 있다. 이렇게 번역된 스크립트는 Selenium 프레임워크에서 사용할 수
있도록 Java, C#, Python 등으로 변환될 수 있으며 심지어 Robot 프레임워크에서 사용할
수 있도록 변환 기능을 제공한다.

--

![그림 7.5 Katalon 스크립트](c7.5.png)

테스트 실행 프레임워크를 지원하는 스크립팅 언어 수준에 따라 다음과 같이 분류할 수 있다.
∙ 선형(Linear) 프레임워크: 스크립트를 작성하는 가장 간단한 형태이다. 모듈과 같은 스크
립트를 구조화하는 수단을 제공하지 않으며 스크립트의 테스트 단계들을 순차적인 흐름
으로 실행한다. 이는 Record&Playback을 지원하는 도구에서 주로 찾아볼 수 있다.
∙ 모듈 기반(Modular Based) 프레임워크: 스크립트를 모듈화할 수 있는 여러 수단을 제공
한다. 특히, 모듈 호출 기능은 한 스크립트에서 다른 스크립트를 호출할 수도 있다. 따라
서 하나의 큰 스크립트를 유지가 용이한 여러 개의 작은 스크립트로 분할하여 관리하는
것이 가능하다. 여러 스크립트에서 공통적으로 필요로 하는 스크립트를 개발하는 비용을
줄일 수 있다.
∙ 데이터 주도(Data-Driven) 프레임워크: 테스트에 사용되는 데이터를 테스트 스크립트의 로
직과 분리하여 보관하는 프레임워크이다. 테스터는 빈번히 어플리케이션의 같은 기능을 다
양한 입력 데이터로 여러 번 테스트해야 하는 상황과 마주한다. 이때, 테스트 데이터 셋을
스크립트 로직 내에 하드코딩 하지 않고 엑셀 시트, 텍스트 파일, CSV(Comma Separated
Value) 파일 등에 보관하여 스크립트의 입력 데이터에 전달하면 테스트 수행 효율을 크게
높일 수 있다. 여러 개의 입력 데이터로 반복하여 테스트될 수 있고, 입력 데이터만 바꾸기
때문에 필요한 테스트 스크립트 개수가 줄어든다. 그리고 테스트 스크립트의 변경이 테스트
데이터에 영향을 주지 않고, 데이터의 변경 또한 테스트 스크립트에 영향을 주지 않는다.
∙ 키워드 주도(Keyword-Driven) 프레임워크: 앞서 언급한 테스트 프레임워크의 공통적인
단점은 테스트 케이스와 애플리케이션 간에 결합이 강하여 애플리케이션이 변경되면 관
련된 수많은 테스트 케이스도 따라서 변경해야 한다는 것이다. 예를 들어, 입력 필드의
위치만 변경되더라도 해당 필드를 사용하는 수많은 스크립트가 변경되어야 한다. 키워드
주도 테스트는 키워드를 사용한 테스트 케이스를 작성하여 테스트 케이스와 애플리케이션 
간에 결합을 줄임으로써 애플리케이션이 변경되어도 테스트 케이스에 직접적으로 영
향을 주지 않도록 하였다. 여기서 키워드란 어플리케이션을 테스트할 때 요구되는 다양
한 액션이나 단계를 캡슐화하는 테스트 케이스를 구성하는 빌딩 블록이다. 예를 들어, 고
객 정보를 애플리케이션에 추가하기 위해서는 고객 이름 입력, 고객 주소 및 전화번호 입
력 및 등록 버튼을 클릭하고 올바르게 추가되었는지 확인하는 여러 단계로 구성된다. 실
제 이런 단계들은 구체적으로 입력 필드를 확인하고 필요한 정보를 전달하는 등의 여러
기술적인 로직이 필요하다. 그러나 키워드 주도 테스트에서는 이들 기술적인 단계를 모
두 캡슐화하여 “ADD A NEW CUSTOMER” 키워드로 정의한다. 테스트 설계자는 이렇
게 미리 정의된 키워드들을 조합하여 테스트 케이스를 작성한다. 따라서 애플리케이션이
변경되어도 키워드로 작성된 테스트 케이스들은 변경할 필요가 없다.

--
![표 7.2 테스트 프레임워크](ct7.2.png)

--
7.2.4 이슈 관리 도구
이슈 관리 도구는 과거에는 버그 추적 도구로 불렸다. 이슈는 사전적 의미로는 사건 또는
문제점으로 해석된다. 따라서 이슈는 버그로 한정되어 취급될 수 있다. 일반적으로 인시던
트는 테스트 프로세스 수행 중에 검출된 문제 즉, 이슈에 해당한다. 그러나 현재 사용 중인
수많은 이슈 관리 도구는 테스트 프로세스에 관련된 문제만이 아닌 프로젝트를 진행하면서
발생하는 모든 사항을 이슈로 처리한다. 다음은 이슈에 해당하는 일부분을 나열한 것이다.
∙ 신규 고객 요구사항
∙ 기능 개선
∙ 버그 수정
∙ 문서 작업
∙ 시스템 설치 작업
따라서 이슈 관리 도구는 프로젝트 관리 도구라고 해도 무리가 없다. 이 절에서는 테스트를
통해 발견된 문제에 한정해서 이슈 관리 도구를 기술한다.
테스트를 통해서 검출된 문제점 즉 이슈는 시스템 품질을 악화시키고 사용자 불만족을 유
발하는 원인이 될 수 있다. 그러므로 식별된 문제점은 소스 코드를 수정해서 제거될 수 있
도록 해야 한다. 만약 문제점이 코드 결함으로 판명되고 이 결함이 매우 단순해서 개발자가
즉각적으로 해결할 수 있으면 바로 소스 코드를 수정하고 결함이 제거된 시스템을 빌드하
면 된다.
하지만 일반적으로 테스트를 통해서 식별된 결함은 재연이 잘되지 않거나 그 근본 원인을
파악하기 어려운 경우가 있다. 따라서 결함이 검출되고 이를 해결하기까지는 적지 않은 시
간이 소요되며, 중요한 결함은 반드시 해결되었는지 관리하여야 한다. 또한, 시스템 테스
트 시 테스터는 결함을 검출하지만 결함을 제거하기 위해서 소스 코드를 변경하는 작업은
개발자 즉 프로그래머의 역할이다. 이런 경우에는 테스터가 검출한 결함 정보가 개발자/프
로그래머와 공유되어야 한다.
그리고 개발자/프로그래머가 소스 코드를 수정하여 결함을 제거했다고 생각하더라도 결함
이 제거되지 않았거나 실수로 새로운 결함이 발생하였을 수도 있다. 그러므로 개발자/프로
그래머가 수정한 소스 코드를 대상으로 다시 테스트를 해야 한다.

이와 같이 결함이 식별되면 그 결함을 완전히 해결할 때까지 검출된 결함은 추적/관리되어
야 한다. 대부분의 이슈 관리 시스템은 이렇게 하나의 결함이 식별부터 완료될 때까지의 이
슈 상태를 추적 관리하는 생명 주기(Defect Life Cycle)를 조직 실정이나 프로젝트 특성에
맞게 조정할 수 있는 기능을 제공한다. 예를 들어, 그림 7.6은 간단한 결함 생명 주기를 보
여 준다.

--
![그림 7.6 결함 생명 주기 예](c7.6.png)

∙ 신규 상태: 테스터는 테스트를 수행함으로써 결함을 식별할 수 있다. 테스터는 식별된 결
함이 해결될 수 있도록 결함에 관련된 정보를 기록하고 보고한다. 이렇게 식별된 결함이
보고된 상태를 “신규”로 정의하도록 한다.
“신규” 상태에서는 보고된 결함에 대한 분석이 수행된다. 그리고 해결할 필요가 없는 경
우에는 해당 결함을 종결시키고 “완료” 상태로 변경한다. 예를 들어, 검출된 결함이 매우
사소해서 수정할 필요가 없다거나 기존에 해결된 결함이라는 확신이 있으면 이런 결함은
바로 “완료” 상태로 변경하도록 한다.
만약 보고된 결함이 해결해야 하는 결함이라면 적절한 개발자에게 해당 결함에 대한 수
정이 지시되며, 결함 상태를 “진행”으로 변경한다. 즉, 결함에 대한 해결 작업이 진행되
고 있음을 의미한다.
∙ 진행 상태: 개발자는 지시된 결함을 해결하기 위해서 소스 코드를 수정한다. 그리고 개발
자 스스로 결함이 해결되었다고 판단이 서면 테스터에게 재테스트를 요청하면서 결함 상
태를 “해결”로 변경하도록 한다.
∙ 해결 상태: 테스터는 개발자에게서 지시된 결함이 해결되었다는 보고를 받았으므로 실제
결함이 해결되었는지 테스트함으로써 확인한다. 즉, 해당 결함을 검출하는 데 사용된 동일한 
테스트 케이스를 다시 사용해서 그 결함이 제거되었는지 확인한다. 만약 결함이 해
결되고 새로운 결함이 발견되지 않았다면 해당 결함 상태를 “완료”로 변경한다.
반면에 테스터가 재테스트를 수행하였을 때 기존 결함이 여전히 발견되거나 기존 결함은
해결되었지만 새로운 다른 결함이 검출된 경우에는 다시 개발자에게 해결을 지시할 수
있다. 그리고 해당 결함 상태를 “진행”으로 변경한다.
∙ 완료 상태: 테스터가 결함이 해결된 것을 재테스트를 통해서 확인한 상태이다. 그러므로
결함이 이 상태에 도달하게 되면 비로소 검출된 결함을 종결시킨다. 또는 “신규”로 등록
된 결함이 매우 사소해서 테스트 관리자가 바로 종결시킬 때도 결함은 “완료” 상태가 될
수 있다.
실제로 결함 생명 주기는 이보다 복잡할 수 있다. 예를 들어, 테스터가 결함 해결을 확인하
고 그 후에 테스트 관리자가 재차 확인할 수도 있다. 그리고 개발자가 결함을 해결하려고
했는데 해당 결함이 재연되지 않아서 테스터에게 결함에 관한 구체적인 상황을 재요청할
수도 있다.
현재 시장에는 이슈 관리를 지원하는 다양한 제품들이 출시되어 있다. 표 7.3은 대표적인
이슈 관리 도구를 나열한 것이다. 이슈 관리 시스템을 도입할 때는 매우 신중해야 한다. 한
번 도입한 이슈 관리 시스템은 사용 중에 타제품으로 변경하는 게 쉽지 않고 변경 시에는
데이터 이관 등에 많은 시간과 비용이 발생한다. 또한, 이슈 관리 도구는 업무 규칙이나 업
무 흐름 등과 직접적으로 연관되므로 도입할 도구를 너무 쉽게 결정해서는 안 된다. 사용
성, 비용, 제공하는 기능, 서비스 제공 형태 등과 같은 여러 요소를 고려해서 도구를 선정
도입하여야 한다.

--
![표 7.3 이슈 관리 도구](ct7.3.png)

--
7.3 테스트 도구 선정
자주 반복되는 테스트를 수작업으로 수행하면 많은 비용을 초래한다. 마찬가지로 속도가
느린 작업이거나 도구를 사용하는 것이 더 안전하게 작업을 수행할 수 있는 경우라면 테스
트 자동화의 대상이 될 수 있다. 반면에, 몇 번 수행되지 않는 테스트를 자동화하는 작업도
비용 대비 효과가 별로 없다. 또한, 테스트 프로세스의 모든 작업을 100% 자동화하는 것도
올바른 선택이 아닐 수 있다. 예를 들어, 요구사항이 자주 변경되는 경우에는 테스트 케이
스도 같이 변경되어야 하며 CAPTCHA(Completely Automated Public Turing test to
tell Computers and Humans Apart, 완전 자동화된 사람과 컴퓨터 판별, 캡차), 폰트나
색상 등이 관련된 경우에는 자동화된 테스트보다는 매뉴얼 테스트가 더 효과적이다. 따라
서 테스트 자동화는 매뉴얼 테스트(Manual test)를 대치하기보다는 상호 보완하는 방향으
로 가야 한다.
테스트 조직 및 프로세스 상황에 따라 반자동화 또는 일부 자동화(Semi-Automation)를
고려할 필요가 있다.
일반적으로 테스트 자동화를 할 때 먼저 자동화를 시도하는 부분이 UI 테스트이다. UI 테
스트를 위해 많은 도구가 소개되고 있으며 시스템 전체를 테스트 대상으로 한다는 점에서
매우 매력적이다.
그러나 UI 테스트를 위한 테스트 케이스가 많아질수록 문제가 발생할 가능성이 커진다. UI
테스트는 시스템 전체의 실행을 전제로 하기 때문에 수많은 UI 테스트 케이스들을 실행하
는 작업은 속도가 느릴 수밖에 없다. 또한, UI는 시스템을 사용하는 사용자가 가장 처음 마
주하는 것으로 UI에 대한 요구사항은 자주 변경되기 마련이다.
UI가 변경되면 해당 테스트 스크립트도 변경해야 한다. 만약 요구사항이 변경되었는데 해
당 테스트 케이스들을 제때 변경하지 않으면 거짓 양성(False positive)이 나타나기 시작
한다. 거짓 양성이란 실제 결함이 아닌데 결함으로 잘못 판단한 경우를 의미한다. 즉, 프로
그램 구현은 문제가 없으나 프로그램 구현 변경에 따라서 제때 수정이 안 된 테스트 케이스
들이 수정된 프로그램에 문제가 있다고 보고한다. 이러한 거짓 양성은 결과 확인 시 사람의
개입을 요구하여 결과적으로 자동화 효율성이 저하될 수밖에 없다.

--
![그림 7.7 테스트 피라미드](c7.7.png)

테스트 자동화 대상과 관련하여 Lisa Crispin의 테스트 피라미드 개념이 널리 알려져 있
다. 그림 7.7은 테스트 피라미드를 보여준다. 피라미드에서 UI 테스트, 통합/API 테스트,
컴포넌트 테스트가 차지하는 영역의 넓이가 다른 것을 볼 수 있다. 각 테스트 타입이 차지
하는 영역의 넓이는 투자 대비 효과(ROI)와 자동화해야 하는 양을 의미한다. 컴포넌트 테
스트에 자동화가 많이 이루어질수록 투자 대비 효과가 많아진다는 것을 의미한다.
컴포넌트 테스트 케이스는 통합 테스트나 UI 테스트보다 쉽게 작성할 수 있으며 테스트 수
행에 따른 피드백이 빠르다. 또한, 결함이 발견되었을 때 단위 테스트는 결함을 발생시키
는 부분을 쉽게 식별하여 수정이 가능한 데 반해 UI나 통합 테스트로 발견한 결함은 결함을
발생시키는 부분을 찾기 어려우므로 결함 수정에 시간이 많이 소요된다.
테스트 피라미드가 시사하는 점은 새로운 테스트 케이스를 개발할 때 UI나 통합 테스트 케
이스 형태로 개발하는 대신 가능한 한 단위 테스트 케이스로 개발할 것을 의미한다. 단위
테스트 케이스로 테스트하지 못할 때만 통합 테스트 케이스를 개발하고 단위나 통합 테스
트 케이스로 부족할 때만 UI 테스트 케이스를 개발한다.

--

![그림 7.8 테스트 도구 선정 프로세스](c7.8.png)

테스트 자동화를 위해 올바른 도구를 선정하는 작업은 매우 중요하다. 그림 7.8은 테스트
도구를 선정하는 프로세스이며 각 단계는 다음과 같은 작업들을 수행한다.
∙ 요구사항 정의: 테스트 도구에 대한 요구사항을 식별하여 정의한다. 도구를 도입할 때 조
직의 프로세스 및 능력을 고려해야 한다. 조직의 테스트 프로세스나 능력이 충분하게 성
숙되어 있지 않으면 도구 사용에 따른 프로세스 변화에 적절하게 대처할 수 없기 때문에
그에 따른 충분한 효과를 볼 수 없다.
∙ 도구 조사: 요구사항을 고려하여 상업용 도구나 오픈소스 소프트웨어 등을 조사한다. 또
한, 자체 개발 가능성도 검토한다.
∙ 도구 평가: 평가 기준을 준비하여 도구가 요구사항에 얼마나 부합하는지 평가한다. 이때
도구 공급자의 명성이나 사후 관리 및 도구 갱신 주기 등과 같은 여러 요소를 고려한다.
∙ 파일럿 프로젝트: 도구의 시험판 버전을 사용하거나 파일럿 프로젝트를 수행하여 도구의
품질을 평가한다. 또한, 도구의 문제점을 도출하고 해결방안을 검토한다.
∙ 도구 선정: 도구 도입에 따른 테스트 프로세스의 개선 효과 등을 고려하여 비용 대비 대
얻을 수 있는 이득을 추정하여 도구를 선정한다.
∙ 도구 도입: 실제로 도구를 조직에 도입하는 단계이다. 도구 도입에 따른 테스트 프로세스
를 개선한다. 도구 배포 계획을 수립하고 교육 및 훈련 계획을 수립한다.

--
Exercise
--


01 다음 중 정적 분석 도구의 용도로 적합하지 않은 경우는?
① 사이클로매틱 복잡도 계산 ② 코딩 표준 준수 검사
③ 사용하지 않은 변수 검출 ④ 테스트 케이스 커버리지 측정
해설 : ④ 동적 분석 도구

02 다음 중 테스트 관리 도구의 목적이 아닌 것은?
① 테스트 계획, 노력 추정, 테스트 일정과 관련된 작업 수행
② 요구사항과 테스트 케이스 추적성 관리
③ 테스트 진행과 보고
④ 모델이나 소스 코드로부터 테스트 케이스 생성
④ 테스트 설계 도구


03 다음은 테스트 도구를 선정하는 프로세스의 한 단계에 대한 설명이다. ( )에 알맞은 용
어는?
도구의 시험판 버전을 사용하거나 ( )를 수행하여 도구의 품질을 평가한다. 또한 도구의 문
제점을 도출하고 해결방안을 검토한다.

![c7.ex03](c7.ex03.png)

--
정답 01 ④ 02 ④ 03 파일럿 프로젝트
--

04 테스트 자동화에 대한 설명으로 올바르지 않은 것은?
① 많은 경우 테스트에 소요되는 수행시간을 줄일 수 있다.
② 적은 비용으로 테스트 환경을 구축할 수 있다.
③ 테스트 환경의 다양화로 테스트 커버리지를 확대할 수 있다.
④ 테스트 실행 및 결과 확인 과정에서 사람의 실수를 줄일 수 있다.
해설 : ② 테스트 도구 구매 및 개발 비용, 테스트 스크립트 개발 비용, 테스트 엔지니어 훈련 비용 등 프로젝
트 초반에 테스트 자동화를 위해 상당한 투자 비용이 발생한다.

05 다음 테스트 자동화 프레임워크 필요성에 대한 설명으로 올바르지 않은 것은?
① 테스트 대상 시스템에 대한 의존도 최대화
② 테스트 케이스 중복 최소화
③ 테스트 스위트(Test Suite)의 효율적 구성 및 관리
④ 테스트 수행 및 결과의 저장 및 관리(DB화)

해설 : 테스트 대상 시스템에 대한 의존도 최소화를 해야 한다.

06 다음 중 SEARCH 모델의 테스트 자동화 구성 요소로 올바르지 않은 것은?
① Analysis (분석) ② Execution (실행)
③ Setup (셋업) ④ Retest (재테스트)

해설 :
SEARCH 모델: Setup(셋업) → Execution(실행) → Analysis(분석) → Report(보고) → Cleanup
(정리) → Help(도움말)

--
정답 04 ② 05 ① 06 ④

--

07 테스트 실행 프레임워크를 지원하는 스크립팅 언어 수준에 따라 다음과 같이 분류할 수
있다. 다음 중 프레임워크에 대한 설명으로 올바른 것은?
① 테스트 주도(Test-Driven) 프레임워크: Record & PlayBack을 지원하는 도구에서 주로
볼 수 있다.
② 데이터 주도(Data-Driven) 프레임워크: 키워드를 사용한 테스트 케이스를 이용하여 애
플리케이션 간에 결합을 줄여준다.
③ 선형(Linear) 프레임워크: 테스트 데이터 셋을 하드 코딩하지 않고 CSV 파일 등에 보관
하여 전달하면 테스트 효율을 높일 수 있다.
④ 모듈 기반(Module Based) 프레임워크: 하나의 큰 스크립트를 유지가 용이한 여러 개의
작은 스크립트로 분할하여 관리할 수 있다.

해설 :
①는 선형(Linear) 프레임워크에 대한 설명이다. 스크립트를 작성하는 가장 간단한 형태이다. 모듈과
같은 스크립트를 구조화하는 수단을 제공하지 않으며 스크립트의 테스트 단계들을 순차적인 흐름으로
실행한다. 이는 Record&Playback을 지원하는 도구에서 주로 찾아볼 수 있다.
②은 키워드 주도(Keyword-Driven) 프레임워크에 대한 설명이다.
③은 데이터 주도(Data-Driven) 프레임워크에 대한 설명이다. 테스트에 사용되는 데이터를 테스트 스
크립트의 로직과 분리하여 보관하는 프레임워크이다.

08 테스트 케이스를 컴퓨터가 실행할 수 있는 스크립트로 변환하는 방법 중 Record &
Playback 방식이 있다. [○/×]

해설 :
테스트 케이스를 컴퓨터가 실행할 수 있는 스크립트로 변환하는 방법 중에서 대표적인 것이 Record&
Playback 방식이다. 옳은 내용이다.
이 방식을 지원하는 도구는 사용자가 브라우저 등을 통해 시스템을 사용하는 행위와 시스템 반응을 스
크립트로 기록하고 이를 다시 반복 실행할 수 있도록 한다. 따라서 도구 사용자가 테스트 스크립트 언어
에 관한 특별한 지식이 없어도 테스트 케이스를 설계하여 실행할 수 있다. Katalon Studio는 Record&
Playback 기능을 제공하는 도구이다.

09 다음 중 테스트 자동화 도구로 가장 거리가 먼 것은?
① GUI 테스트 실행 도구(Selenium, Robotium)
② 소스 코드 빌드 도구(CMake, bitbake)
③ 테스트 관리 도구(Jenkins, Redmine)
④ 형상 관리 도구(Git, Subversion)

해설 :
② 빌드 도구는 테스트 자동화 도구로 보기 어렵다. (빌드 규칙을 서술한 텍스트 파일에 테스트 모듈을
포함하거나 수행하도록 기술하기는 하지만, 빌드 도구 자체가 테스트 자동화 도구로 보기는 어려움)

--
정답 07 ④ 08 ○ 09 ②
--

10 이슈 관리 도구를 이용하여 프로젝트에서 검출되는 결함을 관리하려고 한다. 결함이 식별
되고 완료되기까지의 이슈 상태를 추적하기 위해 다음 보기를 충족하는 결함의 생명 주기
를 설계하고 이를 상태 전이 다이어그램으로 표현하시오. (서답형/상태 간 전이는 단방향
화살표로 표현)
∙ 테스터는 테스트를 수행하여 결함을 식별하고, 결함에 관련된 정보를 기록한 이슈를 “Open”
상태로 등록한다.
∙ “Open” 또는 “Re-open” 상태의 이슈는 개발자에게 할당되며, 개발자는 이슈의 상태를 “In
progress”으로 변경한 후 분석 활동을 수행한다.
∙ 개발자는 소스 코드를 수정하고, 개발자 테스트를 수행하여 결함이 해결되었다고 판단한 후
테스터에게 재테스트를 요청하면서 이슈 상태를 “Resolved”로 변경한다.
∙ 테스터는 실제 결함이 해결되었는지 테스트하여 확인한다.
∙ 테스터는 재테스트를 수행한 후 보고된 결함이 제거되었다면 이슈의 상태를 “Closed”로 변
경하고, 기존 결함이 여전히 발견된다면 이슈의 상태를 “In progress”으로 변경한 후 개발자
에게 해결을 지시한다.
∙ 테스터는 “Closed” 상태의 이슈에 대해 동일한 결함이 재발되는 것을 확인하면 해당 이슈를
“Re-open” 상태로 변경한다.

![c7.ex10](c7.ex10.png)

해설 :

일반적으로 이슈 관리 도구(예：Jira)는 원활한 
이슈 트래킹을 위하여 이슈 상태를 변경함으로써 이슈
의 생명 주기를 관리한다.
개발자/테스터/프로젝트 리더/고객 사이에 효과
적인 이슈 트래킹을 위해 현업에서 적극적으로
사용하는 도구이며, 이슈 트래킹을 자동화하는
데 매우 효과적인 도구이다.
본 문제에서는 테스터에 의한 신규 결함 보고
(Open)부터, 개발자에게 할당(In Progress),
해결 (Resolved), 최종 완료 (Closed) 그리고
리그레션이 발생으로 인한 결함 보고(Re-open)
에 이르는 이슈 생명 주기를 설계할 수 있는 역
량이 있는지 점검한다.

![c7.ex10-1](c7.ex10-1.png)