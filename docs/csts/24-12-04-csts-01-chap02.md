## 제 2 장 테스트 분류와 테스팅 방법

--

### 2.1 개요

테스트와 관련된 많은 개념이 존재한다.  
예를 들어, 아래와 같은 용어들이 있다.

- 컴포넌트 테스트  
- 통합 테스트  
- 시스템 테스트  
- 인수 테스트  

또한, 아래와 같은 개념들도 존재한다.

- 기능 테스트  
- 비기능 테스트  
- 정적 테스트  
- 동적 테스트  

--

다양한 테스트 관련 용어와 개념들은 크게 아래와 같이 구분할 수 있다.

- **테스트 분류**  
  - 테스트 레벨 (컴포넌트, 통합, 시스템, 인수)  
  - 테스트 유형 (기능, 품질)  
  - 테스트 설계 기법

- **테스팅 방법**  
  - 적용하는 개발 생명 주기  
  - 프로젝트 단계 (개발 또는 유지보수)

--

### 주요 설명

1. **테스트 분류**  
   테스트의 레벨, 유형, 설계 기법을 기준으로 다양한 테스트를 분류하고 설명한다.  

2. **테스팅 방법**  
   프로젝트의 상황에 맞춰, 현실적으로 적용할 수 있는 테스트 방법을 설명한다.  
   - 개발 생명 주기  
   - 프로젝트 단계별 접근법

--

## 2.2 테스트 분류

--

### 2.2.1 개요

소프트웨어 테스트는 아래 3가지 기준에 따라 분류될 수 있다.

1. **테스트 레벨**  
2. **테스트 유형**  
3. **테스트 설계 기법**

이 기준들은 서로 독립적이며, 그림 2.1과 같이 3차원 축으로 표현될 수 있다.

--

### 테스트 분류의 3가지 기준

#### 1. 테스트 레벨
- **컴포넌트 테스트**  
- **통합 테스트**  
- **시스템 테스트**  
- **인수 테스트**  

#### 2. 테스트 유형
- **기능 테스트**  
- **비기능 테스트** (예: 성능 테스트, 신뢰성 테스트, 보안 테스트)  

#### 3. 테스트 설계 기법
- **정적 테스트**  
- **동적 테스트**  

--

### 그림 2.1 테스트 분류
![그림 2.1](csts/images/csts_2.1.png)

#### 주요 설명
- **기능 테스트**: 소프트웨어의 기능적 요구 사항을 검증하는 테스트.  
- **비기능 테스트**: 성능, 신뢰성, 보안 등을 포함한 품질 속성을 검증하는 테스트.  
- **테스트 설계 기법**:  
  - 정적 테스트: 코드 실행 없이 수행되는 테스트.  
  - 동적 테스트: 소프트웨어를 실행하며 수행되는 테스트.


--

## 2.2.2 테스트 레벨에 의한 분류

--

### 테스트 레벨의 분류

테스트는 **레벨(Level)**에 따라 아래 4가지로 분류된다.  

1. **컴포넌트(또는 단위) 테스트**  
2. **통합 테스트**  
3. **시스템 테스트**  
4. **인수 테스트**  

--

### 표 2.1 테스트 레벨
![표 2.1](csts/images/csts_table_2.1.png)

--

### 소프트웨어 개발 단계와 테스트 레벨의 관계

4개 레벨의 테스트는 소프트웨어 개발의 각 단계와 밀접하게 연관된다.  

#### 개발 단계별 테스트 대응  
- **요구 분석** → 인수 테스트  
- **구조 설계(아키텍처 설계)** → 시스템 테스트  
- **상세 설계** → 통합 테스트  
- **구현** → 컴포넌트 테스트  

--

### 그림 2.2 V 모델

소프트웨어 개발 각 단계와 테스트 레벨을 알파벳 ‘V’ 형태로 표현한 모델.  
![그림 2.2](csts/images/csts_2.2.png)

#### V 모델의 특징
- **좌측**: 소프트웨어 개발 단계  
- **우측**: 각 단계에 상응하는 테스트 수준  
- 요구사항 정의부터 인수 테스트까지 상호 연관성을 강조.

--

![그림 2.2](csts/images/csts_2.2.png)

--

### 테스트 진행 순서 및 기준

테스트는 **컴포넌트 테스트**부터 **인수 테스트**까지 순차적으로 진행되며,  
각 테스트는 소프트웨어 개발 단계에 맞춰 수행된다.

#### 1. **컴포넌트 테스트**
- **기준**: 상세 설계  
- **대상**: 단위 구성 요소 (예: 함수, 클래스, 컴포넌트)  
- **목적**: 구현된 단위의 기능과 동작을 검증.

#### 2. **통합 테스트**
- **기준**: 아키텍처 설계  
- **대상**: 단위 간의 관계 (예: 호출, 데이터 교환)  
- **목적**: 통합된 단위들이 올바르게 상호작용하는지 검증.

--

#### 3. **시스템 테스트**
- **기준**: 요구 분석  
- **대상**: 완성된 시스템  
- **목적**: 시스템이 명세된 요구사항을 충족하는지 검증.

#### 4. **인수 테스트**
- **기준**: 고객 및 사용자 필요/기대  
- **대상**: 사용자 관점에서의 전체 시스템  
- **목적**: 제품이 고객의 요구와 기대를 충족하는지 검증.

--
## 2.2.3 테스트 유형에 의한 분류

--

### 테스트 유형의 기준

테스트 유형은 소프트웨어의 **동작**과 **특성**에 초점을 맞추어 요구사항 명세서를 기준으로 정의된다.  
요구사항 명세는 두 가지 주요 요구사항을 포함한다.  

1. **기능 요구사항**  
   - 소프트웨어가 수행해야 할 기능.  

2. **품질 요구사항**  
   - 소프트웨어의 성능, 신뢰성, 보안 등 품질 특성.  

--

### 비기능 테스트 (Non-functional Test)

- **목적**: 개별 품질 특성에 초점을 맞춘 테스트.  
  - 예: 성능 효율성 테스트, 신뢰성 테스트, 보안 테스트.  

- ISO 29119 표준에서는 기능 테스트와 비기능 테스트를 **유형 테스트(Type Test)**로 정의.  

--

### 표 2.2 테스트 유형
![표 2.2](csts/images/csts_table_2.2.png)

#### 테스트 유형 분류
1. **기능 테스트**
   - 소프트웨어의 기능적 요구사항 검증.  

2. **비기능 테스트**
   - 품질 요구사항(예: 성능, 신뢰성, 보안)을 검증.


--

## ISO 25010 품질 모델

--

### ISO 25010의 정의

ISO 25010은 **소프트웨어 품질 모델**을 정의하며,  
소프트웨어가 충족해야 하는 다양한 품질 특성을 표준화한 것이다.  

--

### 품질 모델의 주요 특징

#### 1. **주특성 (8개)**  
ISO 25010은 아래 8개의 주특성을 정의한다.  

1. **기능 적합성**  
2. **사용성**  
3. **성능 효율성**  
4. **호환성**  
5. **신뢰성**  
6. **보안성**  
7. **유지보수성**  
8. **이식성**  

#### 2. **부특성**  
각 주특성은 세부적인 **부특성**으로 세분화된다.  
예:  
- **호환성**: 공존성, 상호운영성  
- **유지보수성**: 모듈성, 재사용성, 분석성, 변경 용이성, 테스트 용이성  

--

### 표 2.3 ISO 25010 품질 모델
![표 2.3](csts/images/csts_table_2.3.png)

--

### 품질 특성과 테스트 수행

#### 품질 특성의 중요성  
- 소프트웨어가 충족해야 하는 필수 요소.  
- 기능 요구사항과 함께 소프트웨어 요구사항의 핵심.

#### 테스트 사례
1. **성능 효율성 테스트**  
   - 소프트웨어가 주어진 성능 요구사항을 충족하는지 확인.  

2. **신뢰성 테스트**  
   - 소프트웨어가 신뢰성 요구사항을 만족하는지 검증.  


--
## 2.2.4 테스트 설계 기법에 따른 분류

--

### 2.2.4.1 개요

테스트 설계 기법에 따라 **정적 테스트**와 **동적 테스트**로 나뉜다.  

#### 1. **정적 테스트**
- 소프트웨어를 실행하지 않고 수행.  
- **분류**:  
  - 리뷰 (Review)  
  - 정적 분석 (Static Analysis)  

#### 2. **동적 테스트**
- 소프트웨어를 실행하여 수행.  
- **분류**:  
  - 명세 기반 테스트  
  - 구조 기반 테스트  
  - 경험 기반 테스트  

--

### 2.2.4.2 정적 테스트

#### 특징
- 테스트 대상을 **실행하지 않고** 검증.  
- 대표적인 기법:  
  - 리뷰  
  - 정적 분석  

--

#### 2.2.4.2.1 리뷰

##### 정의  
소프트웨어 산출물의 결함 검출 또는 프로젝트 진행 상황 점검을 위해 **전문가 그룹**이 수행.  

##### 절차  
1. 경영진 준비  
2. 리뷰 계획  
3. 리뷰 절차 개요 설명  
4. 작업물 개요 설명  
5. 개별 준비  
6. 그룹 검토  
7. 재작업  
8. 후속 작업  
--

##### 리뷰 유형  
리뷰의 목적과 수행 방식에 따라 아래와 같이 구분.  

| **리뷰 유형**       | **설명**                             |
|----------------------|--------------------------------------|
| **관리 리뷰**       | 프로젝트 상태 점검 및 관리 목적.     |
| **기술 리뷰**       | 기술적 정확성을 확인하기 위한 리뷰. |
| **인스펙션**         | 공식적이고 정해진 절차를 따르는 리뷰. |
| **워크쓰루**         | 비공식적 리뷰로 협력적 검토 방식.   |
| **감사**             | 표준 및 절차 준수를 확인하는 활동.  |

![표 2.4](csts/images/csts_table_2.4.png)

--

#### 2.2.4.2.2 정적 분석

##### 정의  
**산출물의 구조적 속성**을 분석하여 도구를 이용해 자동화된 방식으로 수행.  
주로 **소스 코드**를 대상으로 한다.

##### 대표적인 정적 분석 방법  
| **분석 방법**       | **설명**                                   |
|---------------------|-------------------------------------------|
| **코드 구조 분석** | 코드의 흐름, 의존성을 점검.              |
| **데이터 흐름 분석** | 데이터 사용의 일관성을 확인.             |
| **코딩 표준 검사**  | 표준 준수를 검토.                       |
| **취약점 분석**     | 보안 취약점을 식별.                     |

![표 2.5](csts/images/csts_table_2.5.png)

--
## 2.2.4.3 동적 테스트

--

### 정의  
동적 테스트는 **소프트웨어를 실행하여 결함을 검출**하는 방법이다.  
테스트 수행 전, 적절한 **테스트 케이스**를 설계해야 한다.

--

### 예시: 자동차 정면충돌 시험  
자동차안전기준 제 102조에 따라, 차량의 정면충돌 시 인체모형이 받는 충격을 측정하는 시험이다.  

#### 시험 조건  
- **속도**: 시속 48.3km로 고정벽에 충돌.  
- **허용 기준**:  
  - **머리 상해 기준값 (HIC)**: ≤ 1,000  
  - **흉부 가속도**: ≤ 60g  
  - **대퇴부 압축 하중**: ≤ 1,020kg  

#### 테스트 케이스 설계  
- 차량의 충돌 속도가 **테스트 케이스**가 된다.  
- 실제로는 기준 속도(48.3km/h)보다 높은 56km/h로 시험을 진행해 **안전 마진**을 확보.  

#### 설계 시 고려 사항  
- **테스트 케이스 수 제한**:  
  소프트웨어의 복잡성 때문에 모든 상황을 테스트할 수는 없다.  
- **효율적 설계**:  
  가능한 **적은 수의 테스트 케이스**로 결함을 검출해야 한다.

--

### 동적 테스트 분류  
테스트 케이스를 결정하는 방법에 따라 세 가지로 분류된다.  

| **분류**            | **설명**                                                              |
|---------------------|---------------------------------------------------------------------|
| **명세 기반 테스트** | 요구사항 명세서에 정의된 소프트웨어의 동작을 기준으로 테스트 케이스를 설계. |
| **구조 기반 테스트** | 소프트웨어 내부 구조(코드 또는 설계)에 따라 테스트 케이스를 설계.         |
| **경험 기반 테스트** | 테스터의 경험과 직관에 따라 테스트 케이스를 설계.                   |

--
## 2.2.4.3.1 명세 기반 테스트와 구조 기반 테스트

--

### 정의 및 개념  
- **명세 기반 테스트**:  
  - **소스 코드에 의존하지 않고** 요구사항 명세를 기준으로 테스트 케이스를 설계.  
  - 예) 임의 테스트(Random Testing): 입력값을 무작위로 생성하여 테스트 수행.

- **구조 기반 테스트**:  
  - **소스 코드나 내부 구조를 분석하여** 테스트 케이스를 설계.  
  - 예) 특정 문장 또는 경로(Path)를 실행하기 위한 입력값 설계.

--

### 비교

| **구분**         | **명세 기반 테스트**                       | **구조 기반 테스트**                     |
|------------------|-----------------------------------------|-----------------------------------------|
| **기준**         | 요구사항 명세                            | 소스 코드 또는 설계                      |
| **목적**         | 시스템 동작 검증                           | 소프트웨어 내부 구조 검증                  |
| **대표 기법**    | 동등 분할, 경계값 분석, 상태 전이 테스트           | 문장 커버리지, 분기 커버리지, 경로 테스트         |
| **특징**         | 블랙박스 테스트(Black Box Testing)         | 화이트박스 테스트(White Box Testing)       |

--

### 명세 기반 테스트와 구조 기반 테스트의 설계 기법  
표 2.6에 나열된 테스트 설계 기법은 다음과 같다:  

| **명세 기반 테스트 기법**           | **구조 기반 테스트 기법**        |
|-----------------------------------|-----------------------------|
| 동등 분할(Equivalence Partitioning) | 문장 커버리지(Statement Coverage) |
| 경계값 분석(Boundary Value Analysis) | 분기 커버리지(Branch Coverage)   |
| 상태 전이 테스트(State Transition Testing) | 경로 커버리지(Path Coverage)     |
| 의사결정 테이블(Decision Table)      | 조건 커버리지(Condition Coverage)|
| 사용 사례 테스트(Use Case Testing)  | 다중 조건 커버리지(MC/DC)        |

--

### 그림 2.3: 명세 기반 테스트와 구조 기반 테스트 개념  
![그림 2.3  명세 기반 테스트와 구조 기반 테스트 개념](csts/images/csts_2.3.png)
- **명세 기반 테스트**는 블랙박스 관점에서 외부 동작 검증.  
- **구조 기반 테스트**는 화이트박스 관점에서 내부 구현 검증.


--

![표 2.6  명세 기반 테스트와 구조 기반 테스트 유형](csts/images/csts_table_2.6.png)

--

## 2.2.4.3.2 경험 기반 테스트  

--

### 정의 및 개념  
- **경험 기반 테스트**:  
  - 기존의 **테스트 경험**, **시스템 및 도메인에 대한 지식**을 바탕으로 수행하는 테스트 방법.  
  - 개발자가 범할 가능성이 있는 **실수나 오류를 예측**하여 테스트 케이스 설계.  

--

### 오류 추정 (Error Guessing)  

#### 개념  
- **오류 추정**은 개발자가 범할 수 있는 실수를 예상하여 이에 대한 결함을 검출하도록 설계하는 테스트 방법.  
- **테스터의 경험과 직관**을 바탕으로 잠재적인 오류 상황을 나열하고 이를 기반으로 테스트 수행.

#### 예시  
- 특정 입력값 처리:  
  - `tan(x)` 함수에서 **90°**와 같이 특별한 값에 대한 처리가 누락된 오류 상황.  
  - 가변 크기 입력에서 다음과 같은 테스트 상황 고려:  
    - 입력 크기가 0인 경우.  
    - 일치하는 값을 찾지 못하는 경우.  

#### 특징  
- 일반화된 기법이나 절차를 정의하기 어려움.  
- **동등 분할**, **경계값 분석** 등 **명세 기반 테스트**와 병행 사용 가능.  
  - 예) 유효하지 않은 값의 영역(Invalid Partition) 결정 시 경험 활용.  

--

### 대표적인 오류 추정 사례  

#### 정렬 프로그램 테스트  
1. 입력 목록 크기가 **0**인 경우.  
2. 입력 목록이 하나의 데이터만 포함.  
3. 모든 데이터가 동일한 경우.  
4. 입력 목록이 이미 정렬된 상태.  

--

### 표 2.7: 오류 추정 기법 예  
표 2.7에는 테스트 시 고려할 수 있는 대표적인 오류 추정 상황이 나열되어 있다.  
![표 2.7  오류 추정 기법 예](csts/images/csts_table_2.7.png)

#### 활용 사례  
- 예상치 못한 사용자 입력값 처리 확인.  
- 다양한 오류 상황을 미리 파악하여 테스트 범위 확장.


--
## 2.2.4.3.2.2 탐색적 테스트  

--

### 정의  
- **탐색적 테스트**는 사전에 구체적인 테스트 케이스를 설계하지 않고, **테스트 대상에 대한 이해**, **테스트 케이스 설계**, **테스트 실행**을 **병행**하는 방식.
- 테스트를 진행하면서 **테스트 케이스를 즉석에서 결정**하고, 결과에 따라 **다음 테스트를 결정**.

--

### 특징  
- **테스터의 지식**에 의존:  
  - 테스트 대상에 대한 이해도, 경험, 가능성 있는 결함 및 위험 요소에 대한 파악이 중요.
  - **테스트 문서화 없음**: 
    - 사전 설계서 없이 즉석에서 테스트 케이스를 설계하고 실행.
    - 자동화 도구를 통해 **로그**와 **결과**는 자동으로 생성될 수 있음.
- **테스트 차터(Chart)** 작성 가능:
  - **테스트해야 하는 세부 피처** 및 관련된 이슈 등을 기록.

--

### 장점과 단점

#### 장점  
- **애자일 환경에 적합**:  
  - 개발 주기가 짧은 시스템에 유용.  
  - 세부적인 테스트 명세서 관리 없이 빠르게 테스트 수행 가능.

#### 단점  
1. **시스템에 대한 초기 정보 부족**:  
   - 결함을 검출하려는 목표 없이 시스템을 탐색하면 과도한 시간이 소모될 위험.
2. **중복 테스트**:  
   - 여러 명 혹은 팀이 참여할 경우 동일한 기능을 반복적으로 테스트할 위험.
3. **커버리지 판단 어려움**:  
   - 테스트 범위를 명확히 문서화하지 않기 때문에, 테스트가 충분한지 판단하기 어려움.

--

### 활용 예시
- **웹 응용 시스템**의 테스트에 적합.
- **애자일 개발** 방식의 시스템에서는 짧은 개발 주기로 인해 세부적인 테스트 문서를 작성할 시간이 부족하기 때문에 탐색적 테스트가 효과적.

--
# 2.3 테스팅 방법
## 리그레션 테스트 (Regression Testing)

--

### 소프트웨어 변경의 다양한 배경

- **결함 수정**: 사용자가 보고한 문제점 해결
- **기능 추가**: 새로운 기능 구현
- **성능 개선**: 시스템 효율성 향상
- **환경 적응**: 새로운 운영 환경에 대응
- **유지보수성 향상**: 코드 구조 개선

--

### 리그레션 테스트의 정의

- **목적**: 소프트웨어 변경으로 인한 부작용 확인
- **핵심 검증 사항**:
  - 의도하지 않은 결함 발생 여부
  - 기존 요구사항 충족 여부

--

### 리그레션 테스트 전략

1. **Retest-all 전략**
   - 모든 테스트 케이스 재실행
   - 가장 포괄적이지만 시간과 비용 많이 소요

2. **선택적 리그레션 테스트 전략**
   - 변경된 부분과 관련된 테스트만 선별 실행
   - 효율성 증대

3. **테스트 최소화 전략**
   - 최소한의 테스트 케이스로 최대 검증
   - 테스트 범위 최적화

4. **테스트 우선 순위화 전략**
   - 중요도와 위험도에 따라 테스트 순서 결정
   - 핵심 기능 우선 검증

--

### 리그레션 테스트 레벨

- **컴포넌트 테스트**
- **통합 테스트**
- **시스템 테스트**

각 레벨별로 순차적이고 체계적인 테스트 수행


--

# 2.3.3 소프트웨어 생명 주기 모델과 테스트

--

## 소프트웨어 생명 주기의 이해

### 기본 개념
- **정의**: 소프트웨어 개발 체계의 추상적 표현
- **구성**: 순차적 또는 병렬적 단계
- **주요 단계**:
  - 요구사항 수집 및 분석
  - 설계
  - 모듈 구현
  - 테스트
  - 유지보수

--

## 생명 주기 모델과 테스트 접근 방식

### 모델별 테스트 특성

1. **순차적 생명 주기 모델**
   - 테스트는 구현 완료 후 단일 수행
   - 한 번의 테스트 주기

2. **진화형 및 애자일 모델**
   - 반복적이고 점진적인 테스트
   - 지속적인 테스트 수행
   - 각 반복 주기마다 테스트 실시

--

## 폭포수 모델의 테스트 특징

### 장점
- 구현 완료 후 모든 산출물 확보
  - 요구사항 명세
  - 구조 설계
  - 상세 설계
  - 소스 코드

### 단점
- 결함 발견 시기가 늦음
- 결함 해결 비용 증가
- 개발 종료 시점에서 근본적 문제 해결 어려움

--

## 결함 발견의 비용 관점

### 결함 발견 시기별 비용 차이
- **초기 단계 결함 발견**: 낮은 비용
- **개발 후반/완료 시점 결함 발견**: 높은 비용
  - 구조적 문제일 경우 특히 심각
  - 시간과 자원 추가 소요
  - 프로젝트 일정 지연 위험

--

# V-모델과 진화적 개발 모델

--

## V-모델

- **테스트와 개발의 병행**  
  개발 시작과 함께 테스트도 시작됨.

- **테스트 레벨 존재**  
  각 개발 단계에서 발생하는 결함을 검출할 수 있는 테스트 레벨이 존재.

- **테스트 단계**  
  - 요구사항 분석 단계: 시스템 테스트를 위한 테스트 계획 설계 및 테스트 케이스 도출.
  - 구조 설계 단계: 통합 테스트 테스트 계획 수립 및 테스트 케이스 도출.

- **동적 테스트와 정적 테스트**  
  개발 산출물에 대한 정적 분석과 리뷰를 통해 결함을 검출.

--

## 진화적 개발 모델

- **개발 방식**  
  이터레이션(Iteration)과 점진적(Incremental) 방식으로 개발 진행.

- **개발 프로세스**  
  - 핵심 부분을 개발 후, 추가 요구사항을 이터레이션을 통해 개선.
  - 각 이터레이션마다 테스트 계획을 작성하고, 테스트를 수행.

- **각 이터레이션의 단계**  
  요구사항 분석, 설계, 구현, 테스트의 순차적 단계로 구성.

- **테스트 수행**  
  각 개발 단계에서 테스트 관련 프로세스가 수행됨.

--

# 애자일 개발 방법론

--

## 특징

- **반복적이고 점진적인 개발**  
  진화적 개발 모델과 유사한 방식으로 반복적이고 점진적인 접근 방식을 따름.

- **TDD (테스트 주도 개발)**  
  - 프로그램에 대한 테스트 케이스를 먼저 작성.
  - 이 테스트 케이스를 통과하는 실제 프로그램의 코드를 나중에 작성.

- **지속적 통합 (CI, Continuous Integration)**  
  - 통합이 한 번의 시점에 이루어지는 것이 아니라, 지속적으로 통합을 수행.
  - 애자일 개발에서 중요한 실천 규칙으로, 개발 중에 코드를 지속적으로 통합하여 빠른 피드백을 받음.


--

# 위험 기반 테스트

--

## 개요

- **제약 내에서 테스트 수행**  
  테스트는 소프트웨어 프로젝트와 마찬가지로 주어진 비용과 일정 내에서 수행되어야 함.

- **자원 제약 고려**  
  주어진 자원 내에서 테스트 목적을 달성하기 위한 노력 필요.
  - 테스트 범위 결정 시 비용과 일정을 고려.
  - 단위 테스트, 통합 테스트, 시스템 테스트의 수행 수준 결정.

--

## 테스트 대상과 범위 결정

- **테스트 범위 한정**  
  테스트 범위를 전체 시스템의 일부로 한정시켜 테스트 비용을 절감할 수 있음.
  그러나 테스트되지 않은 부분에서 결함이 발생할 위험이 증가하고, 이는 소프트웨어 품질에 부정적인 영향을 미침.

- **위험 기반 테스트**  
  - 테스트 대상을 결정할 때 미수행에 따른 **위험 수준**을 고려해야 함.
  - 위험 수준이 낮은 것들은 테스트 대상에서 제외 가능, 그러나 위험 수준이 높은 것들은 반드시 테스트 대상에 포함해야 함.

--

## 위험 분석을 바탕으로 한 테스트 활동

- **위험 분석 기반**  
  피처에 대한 위험 분석을 바탕으로 테스트 계획, 설계 및 실행을 수행하는 것.

--

# 모델 기반 테스트

--

## 개요

- **모델 기반 테스트의 정의**  
  - 모든 명세 기반 테스트는 테스트 대상에 대한 기대 동작을 표현하는 일종의 모델을 이용.
  - 모델은 자연어, 상태 전이도, UML 다이어그램, 의사결정표 등 다양한 형식으로 표현될 수 있음.

--

## 기존의 테스트 방식과 모델 기반 테스트의 차이점

- **기존 테스트 방식**  
  - 모델을 이용하더라도 테스트 입력 및 출력을 수작업으로 결정.
  
- **모델 기반 테스트**  
  - 정형화되고 상세한 모델을 바탕으로 자동으로 테스트 계획, 테스트 케이스, 절차, 입력 및 예상 결과 등을 추출.
  - 테스트 절차에서 입력 및 출력을 자동으로 생성할 수 있어 효율적이고 체계적.

--

## 장점

- **자동화**  
  - 모델 기반 테스트는 대부분의 테스트 활동을 자동화할 수 있어 효율적.
  
- **문제 조기 식별**  
  - 모델에 존재하는 문제를 조기에 식별하여 개발 단계에서 결함을 검출할 수 있음.
  
- **안전 필수 소프트웨어**  
  - 장애 발생 시 많은 비용이 유발되는 안전 필수 소프트웨어(예: 자동차, 의료)에 사용됨.

--

## 단점

- **모델 구축 비용**  
  - 정형적이고 상세한 테스트 모델을 구축하는 데 추가 비용이 들 수 있음.

--

## 모델 표현 방법

- **정형적 표현법**  
  - 의사결정표, UML 상태 다이어그램, UML 액티비티 다이어그램 등을 사용하여 테스트 대상의 동작을 모델링.


--

# Exercise

--

### 01   명세 기반 테스트와 구조 기반 테스트 방법은 대표적인 정적 테스트 방법이다.[○/×]
해설 : 명세 기반 방법과 구조 기반 방법은 동적 테스트 방법이다.

--

### 02   정적 테스트에 대한 설명으로 타당하지 않은 것은 무엇인가? 
- ① 동적 테스트 방법에서 검출하기 힘든 오류를 찾아낸다.
- ② 개발 초기에 오류를 찾아내어 품질을 향상시킨다.
- ③ 프로그램 개발단계에서 산출되는 결과물에서 결함을 찾아낸다.
- ④ 코드 분석을 기반으로 프로그램을 실행하여 오류를 찾아낸다.

해설 : ④ 프로그램을 실행하는 방법은 동적 테스트이다.

--

03   명세기반 테스트는 특성상 시스템 및 인수 테스트 단계에서만 수행한다.[○/×]

해설 : 명세 기반 테스트는 대상 시스템의 명세 정보를 얻을 수 있는 한, 적용 대상에 제한이 없으며 컴포넌트 테스트, 통합 테스트, 시스템 테스트 및 인수 테스트 전 과정에 걸쳐 사용될 수 있다.

--

04   오류 추정은 특정 소프트웨어에 대해 테스터의 직관과 경험을 활용하여 어떤 유형의 결함이 발생할 것을 예측하여 테스트하는 방법이다. [○/×]
해설 : 오류 추정에 대한 설명이다.

--

05 다음 중 탐색적 테스팅에 대한 설명으로 가장 거리가 먼 것은?
① 세션 기반 테스팅을 사용하여 테스트를 구조화한다.
② 테스트 케이스를 먼저 디자인하지 않는다.
③ 애자일 개발 방법에 적합하지 않다.
④ 다른 테스트 기법의 사용을 포함할 수 있다.

해설 : ③ 탐색한 테스팅은 애자일 방법을 사용하는 웹 응용 시스템의 테스트에 적합한 방법이다.

--

정답   01 ×  02 ④  03 ×  04 ○  05 ③

--

06   다음 설명 중에서 모델 기반 테스트와 거리가 가장 먼 것은?
① 개발 단계 산출물에 존재할 수 있는 결함을 검출할 수 있다는 이점도 있다.
② 장애가 발생하였을 때 큰 비용이 유발되는 자동차, 의료 등 안전 필수 소프트웨어를 대상 으로 수행되고 있다.
③ 모델을 바탕으로 테스트 계획을 수립하고, 테스트 케이스, 테스트 절차, 테스트 입력 및 예상 결과 등을 결정한다.
④ 기존의 테스팅에서 이용하던 의사결정표, 순서도 등은 모델이 아니다.

해설 : 모델 기반 테스트 대상의 동작에 대한 상세한 모델링에는 의사결정표, UML 상태 다이어그램, UML 액티비티 다이어그램을 비롯한 정형적 표현법을 사용할 수 있다.

--

07   테스트 대상의 동작에 대한 정형적 명세를 바탕으로 테스트 케이스 및 테스트 절차를 자 동으로 생성하는 방식으로 수행되는 테스팅을 무엇이라고 하는가?

해설 : 모델 기반 테스트는 테스트 절차를 수행할 수 있는 정보가 자동으로 추출될 수 있을 정도로 정형화되고 상세한 모델을 바탕으로 하여, 테스트 계획을 수립하고, 테스트 케이스, 테스트 절차, 테스트 입력 및 예상 결과 등을 결정한다.

--

08   테스트 스텁 작성 비용이 많이 드는 경우에는 상향식 통합 테스트를 수행하면 좋다. [○/×]
해설 : 하위에 있는 모듈들을 먼저 통합하기 때문에 스텁을 작성할 필요가 없다.

--

09 다음 테스트 종류 중, 분류 기준이 다른 하나는 무엇인가?
① 성능 테스트 (Performance Test)
② 시스템 테스트 (System Test)
③ 보안성 테스트 (Security Test)
④ 신뢰성 테스트 (Reliability Test)

해설 : 시스템 테스트는 단위, 통합, 시스템과 같이 테스트 레벨(단계)에 의한 구분이고, 나머지는 테스트 특성 (유형)에 따른 구분임

--

정답   06 ④  07 모델 기반 테스팅  08 ○  09 ②

--

10 다음 괄호 안에 들어갈 가장 알맞은 방법은 무엇인가?
ISO/IEC/IEEE 29119에서는 테스트 방법을 (          ) 기반 테스트, 명세 기반 테스트, 구조 기반 테스트로 분류한다. 

① 경험 ② 키워드 ③ 요구사항 ④ 시나리오

--

정답   10 ①