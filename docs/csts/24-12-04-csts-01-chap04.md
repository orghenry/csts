# 제 4 장 품질 특성과 비기능 테스트

--

## 4.1 개요

ISO 25010 품질 모델에 따라 소프트웨어 품질 특성을 테스트하는 방법을 설명합니다. ISO 25010 모델에서는 소프트웨어 품질을 8가지 주요 특성으로 나누고, 각 특성에 대한 하위 품질 특성을 정의하고 있습니다.

--

## 8가지 품질 특성

- **기능 적합성 (Functional Suitability)**  
  - 제품 또는 시스템이 명시적 또는 묵시적 요구를 충족하는 기능을 제공하는 정도.
  
- **성능 효율성 (Performance Efficiency)**  
  - 명시된 조건 하에서 사용된 자원에 비해 성능이 얼마나 효율적인지.

- **호환성 (Compatibility)**  
  - 다른 시스템이나 구성 요소와의 상호작용을 원활하게 수행할 수 있는 능력.

- **사용성 (Usability)**  
  - 사용자들이 특정 환경에서 제품이나 시스템을 얼마나 효과적이고 만족스럽게 사용할 수 있는지.
  
- **신뢰성 (Reliability)**  
  - 특정 조건에서 장기간 오동작 없이 요구된 기능을 수행하는 정도.

- **보안성 (Security)**  
  - 시스템이 정보 및 데이터를 얼마나 잘 보호하는지.

- **유지보수성 (Maintainability)**  
  - 제품이나 시스템이 유지보수되기 위한 효율성 정도.

- **이식성 (Portability)**  
  - 다양한 플랫폼에서 운영될 수 있는 능력.

--

## 그림 4.1

ISO 25010 품질 모델의 시각적 다이어그램은 각 품질 특성 간의 관계를 보여줍니다.

--


--

![그림4.1 ISO 25010 품질 특성](csts/images/csts_4.1.png)

--

표 4.1은 부특성에 대한 설명이다. 이러한 품질 특성에 따라 다양한 테스트 설계 기술을 사 용하여 테스트 케이스를 설계할 수 있다.

표 4.1  ISO 25010 품질 특성

![표 4.1  ISO 25010 품질 특성](csts/images/csts_table_4.1.png)

--

![표 4.1  ISO 25010 품질 특성](csts/images/csts_table_4.1-1.png)

--
# 4.2 기능 적합성 테스트

--

기능 적합성(Functional Suitability) 테스트는 시스템이 사용자의 요구사항을 얼마나 만족하는지 평가하는 방법입니다. 이를 통해 시스템이 제공하는 기능이 사용자 요구에 부합하는지를 확인할 수 있습니다. 표 4.1에서 기능 적합성의 부특성으로 **기능 완전성**, **기능 정확성**, **기능 적절성**을 들 수 있습니다.

--

## 기능 적합성의 부특성

1. **기능 완전성 (Functional Completeness)**  
   - 사용자가 요구하는 기능을 시스템이 얼마나 잘 제공하는지 평가.  
   - **테스트 방법:** 명세 기반 테스트. 유스케이스나 사용자 스토리에서 테스트 케이스를 추출하고, 요구사항과 테스트 케이스 간의 추적성을 유지하여 시스템이 얼마나 많은 기능을 제공하는지 파악.

2. **기능 정확성 (Functional Correctness)**  
   - 시스템이 사용자가 기대하는 대로 정확하게 동작하는지 평가.  
   - **테스트 방법:** 명세 기반 또는 구조 기반 테스트. 전체 소프트웨어 기능 중에서 사용자의 의도된 목적을 정확하게 달성할 수 있는 기능의 수로 정확성 판단.

3. **기능 적절성 (Functional Appropriateness)**  
   - 사용자의 목적을 달성하는 데 시스템이 얼마나 도움을 주는지 평가.  
   - **테스트 방법:** 목적을 나열하고 각 목적별로 적절성을 테스트. 예를 들어, 해당 목적을 달성하는 데 필요한 기능이 누락되었는지 또는 올바르게 구현되었는지를 테스트.

--

이러한 테스트들은 시스템이 사용자의 요구를 만족시키는지, 정확하게 기능을 수행하는지, 그리고 제공된 기능이 사용 목적에 적합한지 평가하는 데 도움을 줍니다.

--
# 4.3 성능 효율성 테스트

--

소프트웨어 시스템의 성능을 평가할 때 고려해야 할 주요 요소들은 다음과 같습니다:

- **CPU 사이클, 디스크, 주기억공간**과 같은 자원의 사용
- 주어진 시간 동안 처리할 수 있는 작업량
- 자원이 할당되기를 기다리는 태스크의 수 등

성능에 대한 요구사항은 **구체적이고 검증 가능한 형태**로 명세서에 기술되어야 하며, 명시되지 않거나 불명확한 요구사항은 성능 검증을 어렵게 만듭니다.

--

## 성능 요구사항 예시

1. **명확하지 않은 요구사항**  
   - "컴파일러는 어떤 모듈이든 1초 이내에 컴파일할 수 있어야 한다."
   - 문제점: 1초 이상 걸리는 모듈을 발견하면 성능이 불만족임을 확인할 수 있지만, 모든 모듈이 1초 이내에 컴파일된다고 해서 성능이 만족한다고 볼 수 없음.

2. **검증 가능한 요구사항**  
   - "평균적인 부하가 있는 상황에서 시스템을 가동할 때 CPU 사용률이 50%를 초과해서는 안 된다."
   - "관찰된 기간 동안에 최대 부하가 걸린 상황과 동일한 상태에서 CPU 사용률이 90%를 초과해서는 안 된다."

--

## 성능 테스트 방법

### 벤치마크 테스트 (Benchmark Test)
- **벤치마크**란 실제 비교 대상을 두고 하드웨어나 소프트웨어 성능을 비교 시험하는 방법입니다.
- **목표:** 실제 환경과 동일한 상황에서 반복적으로 테스트하여 성능을 평가.
- **운영 환경 및 작업 부하 반영:** 테스트에서 운영 환경 및 작업 부하 패턴을 정확하게 반영해야 함.

--

## 벤치마크 개발 시 고려사항

1. **운영 프로파일(Operational Profile):**  
   - 시스템이 실제로 사용되는 패턴을 반영해야 합니다.
   - 예시: 100명이 동시에 사용하는 패턴 반영.

2. **부하 상황 반영 기간:**  
   - 1시간, 24시간, 일주일 등 다양한 기간에 걸친 부하를 반영할 수 있습니다.
   - **반복성(Repeatability):** 예를 들어, 일주일 동안의 부하 상황이 다음 주에도 비슷하다면 그 상황만 고려하여 벤치마크를 개발할 수 있습니다.

--

## 성능 테스트 유형

--
표 4.2  성능 테스팅 종류

![표 4.2  성능 테스팅 종류](csts/images/csts_table_4.2.png)

--
그림 4.2: 성능 테스팅 비교

![그림 4.2  성능 테스팅 비교](csts/images/csts_4.2.png)

--

# 심화 노트: Little’s Law와 성능 테스트

--

## 리틀의 법칙 (Little’s Law)

리틀의 법칙은 성능 테스트에서 반드시 알아야 하는 매우 중요한 법칙입니다.  
이 법칙은 발명자 **존 리틀** 박사의 이름을 따서 만들어졌으며, 직관적이고 간단한 법칙입니다.

리틀의 법칙은 시스템에 오랜 시간 동안 머물러 있는 고객의 평균 수치는,  
**평균 실제 도착률**과 **시스템에서 고객이 머문 평균 시간**을 곱한 값과 같다는 것을 설명합니다.

--
![ctable_4.a1](csts/images/csts_table_4.a1.png)

--

## 성능 테스트 관점에서의 리틀의 법칙

리틀의 법칙을 성능 테스트에서 사용하기 위해 필요한 용어는 다음과 같습니다.

| 용어                | 설명                        |
|---------------------|-----------------------------|
| **Concurrent User**  | 처리량(TPS) * 요청 간격(Request interval) |
| **Active User**      | 처리량(TPS) * 응답 시간(Response time) |
| **Inactive User**    | 처리량(TPS) * Think time    |

--

## 리틀의 법칙 공식

리틀의 법칙을 성능 테스트 관점에서 표현하면 다음과 같습니다:

- **Concurrent User** = 처리량(TPS) * 요청 간격(Request interval)  
  = 처리량(TPS) * (응답 시간(Response time) + Think time)
  
- **Active User** = 처리량(TPS) * 응답 시간(Response time)
  
- **Inactive User** = 처리량(TPS) * Think time

리틀의 법칙은 **목표 처리량에 요구되는 동시 사용자 수**를 산정할 때 사용됩니다.

--

## 리틀의 법칙 적용 예시

예를 들어, 목표 처리량이 50TPS이고 시스템의 평균 응답 시간(think time은 0이라고 가정)이 2초라면,  
성능 테스트에 필요한 가상 사용자 수는 **100명**입니다.  
따라서 100명의 가상 사용자를 대신하는 쓰레드를 생성하여 성능 테스트를 수행해야 합니다.

--

## 성능 테스트에서의 Ramp Up과 Ramp Down

- **Ramp Up:** 가상 사용자를 이용하여 부하를 주는 패턴입니다.  
  - 가상 사용자 유입 패턴을 정의하는 것으로, 동시에 유입할지 일정 시간 간격에 따라 유입할지를 설정합니다.
  - 예시: Ramp up 기간이 100초이고 10명의 가상 사용자가 있다면, 100/10 = 10초 주기로 한 명씩 유입됩니다.

- **Ramp Down:** 성능 테스트 종료 후 가상 사용자 수를 줄이는 패턴입니다.

--


--

# 4.4 호환성 테스트

--

## ISO 25010 품질 모델의 호환성

ISO 25010 품질 모델은 호환성을 **공존성(Co-existence)**과 **상호운영성(Interoperability)**으로 설명합니다.

- **공존성**: 다른 소프트웨어와 환경 및 자원을 공유하면서 요구된 기능을 효율적으로 수행하는 정도를 나타냅니다.
- **상호운영성**: 여러 시스템이 정보를 교환하거나 교환된 정보를 성공적으로 사용할 수 있는 정도를 의미합니다.

--

## 공존성 문제 예시

공존성이 유지되지 않을 때 발생할 수 있는 문제의 예로는 보안 프로그램을 여러 곳에서 다운로드 받아 설치할 때 기존 애플리케이션이 정상적으로 동작되지 않는 경우를 들 수 있습니다.  
이러한 문제는 설치된 보안 프로그램들이 메모리와 같은 자원을 사용하여 충돌이 일어나거나 자원을 독점적으로 사용할 때 발생합니다.

--

## 공존성의 중요성

공존성은 특히 시스템의 장애 발생이 인명 손실이나 막대한 재산 피해, 또는 치명적인 환경 파괴를 가져올 수 있는 **안전성 필수(Safety-critical)** 시스템에서 매우 중요합니다.  
예시: 자동차 기능 안전성 국제 표준인 **ISO 26262**에서는 다른 시스템 요소들이 공존하기 위한 기준을 위험 등급으로 엄격하게 규정하고 있습니다.  

**ISO 26262 준수를 위한 핵심사항인 ASIL(Automotive Safety Integrity Level)**은 위험 노출 가능성(E:Exposure, E0~E4), 통제 가능성(C:Controllability, C0~C3), 심각성 평가(S:Severity, S0~S3)를 기반으로 위험성을 평가합니다.  
이 세 가지 사항을 조합하여 도출된 위험성 등급은 **QM(Quality Management)**(준수 불필요)부터 가장 낮은 등급인 **A등급**에서 **D등급**까지로 분류됩니다.

--

## 상호운영성

**상호운영성**은 특별한 노력을 기울이지 않아도 시스템 또는 제품이 다른 시스템이나 제품과 함께 잘 동작할 수 있는 능력을 의미합니다.  
이러한 상호운영성은 **사물인터넷(IoT)**이나 **국방정보시스템**을 구축할 때 매우 중요합니다.

--

## IoT와 상호운영성

많은 전문가는 **IoT** 가치의 상당 부분이 다양한 IoT 시스템 간의 상호운영성 달성 능력에 달려 있다고 입을 모은다.  
구글, 마이크로소프트, 애플, 시스코, 인텔, IBM 등 대형 IT 기업이 자신의 IoT 기술을 가지고 있습니다.  
하지만 어느 한 기업이 보유한 IoT 솔루션만으로 모두를 만족시킬 수는 없습니다. 따라서 IoT 공급업체의 기술을 평가할 때 상호운영성이 핵심 기준이 될 수밖에 없습니다.

--

## IoT 상호운영성 및 표준

IoT 상호운영성을 위해 데이터 교환 및 관리 역할을 하는 **국제표준 기반의 플랫폼 기술**이 활발히 개발되고 있습니다.  
각 표준협의체에서는 각각의 인증프로그램을 운영하여 상호운영성 보장을 위한 표준에 적합한 제품이 시장에 출시되도록 유도하고 있습니다.

--

## 국방정보시스템과 상호운영성

국방정보시스템은 **지휘 통제**, **전략 전술**, **물자 관리** 등 다양한 분야에서 사용되고 있습니다.  
군의 전력을 극대화하기 위해서는 다양한 국방정보시스템 간의 효과적인 상호운영성이 전제되어야 합니다.

--

## LISI 모델 (Level of Information System Interoperability)

**LISI**(Level of Information System Interoperability) 모델은 국방정보시스템 간의 상호운영성을 평가하기 위한 모델로, 미국 방성의 연구비를 받아 **카네기 멜론대학 SEI 연구소**에서 개발되었습니다.  
LISI는 시스템 간의 정보 교환 능력을 설명하는 상호운영성 성숙도 모델(Interoperability maturity model)을 보여줍니다.  
이 성숙도 모델은 요구되는 상호운영 능력을 **절차**, **응용**, **인프라**, **데이터** 네 가지 측면으로 구분하여 **0부터 5까지 여섯 단계 수준**으로 구성됩니다.

--




표 4.3  LISI 능력 모델

![표 4.3  LISI 능력 모델](csts/images/csts_table_4.3.png)

--

## 한국군에서의 LISI 모델 적용

한국군에서도 LISI 모델을 바탕으로 상호운영성을 측정하고 있으며, LISI에 따른 상호운영성 평가를 위해 **전자질의평가 방법**을 주로 사용해 왔습니다.  
이 방법은 미리 준비된 상호운영에 관한 질의서에 개발 시스템 구현 정보 옵션을 입력하고, 질의서에 입력된 정보를 바탕으로 평가 대상 시스템의 상호운영 능력과 관련된 정보를 종합한 **상호운영 프로파일**을 작성한 후, 상호운영 프로파일을 바탕으로 상호운영 수준을 평가합니다.

--
# 4.5 사용성 테스트

--

## 사용성 정의

ISO 25010에서 **사용성(Usability)**은 특정한 사용자들이 주어진 사용 환경(특정 사용 컨텍스트)에서 특정한 목적을 달성하기 위해 제품이나 시스템을 사용할 때 얻게 되는 **효율성**, **효과성** 및 **만족도**로 정의됩니다.  
ISO 9241-11(Guidance on usability)에서도 동일하게 사용성을 정의하고 있습니다.

--

## 사용성 평가 품질특성

표 4.4는 **ISO 9241-11**과 **ISO 25010**에서 설명된 **효과성**, **효율성**, **만족도**에 대한 설명입니다.

![표 4.4 사용성 평가 품질특성](csts/images/csts_table_4.4.png)

--

## ISO 9241-11 사용성 프레임워크

그림 4.3은 **ISO 9241-11**에서 규정한 사용성을 측정하고 평가하기 위해 구성요소들을 측정⋅검증 가능하도록 분해하고, 그 관계를 표현한 **프레임워크**입니다.  
이 프레임워크에서 볼 수 있듯이 **효과성**, **효율성**, **만족도**는 시스템이나 제품의 사용성 수준을 측정하는 기준으로 사용할 수 있습니다.

![그림 4.3 ISO 9241-11 사용성 프레임워크](csts/images/csts_4.3.png)

--

## 사용성 측정 예시

표 4.5는 **한국과학기술정보연구원(KISTI)**에서 2011년 발간한 “웹사이트 사용성 개선을 위한 단계별 전략”에 관한 보고서에 소개된 **ISO 9241-11**의 **효과성**, **효율성**, **만족도**를 기반으로 하는 사용성 측정 예시입니다.

--


표 4.5  사용성 측정 예시

![표 4.5  사용성 측정 예시](csts/images/csts_table_4.5.png)

--
# 사용성 평가

--

## ISO 25010에서의 사용성 부특성

ISO 25010에서 **사용성**은 다음 6가지 부특성으로 나뉩니다. 사용성 평가에 이러한 특성들을 고려할 수 있습니다:

1. **적합 인식성 (Appropriateness recognisability)**: 사용자가 자신의 필요에 시스템이 적합한지를 인식할 수 있는 정도
2. **학습 용이성 (Learnability)**: 사용자가 소프트웨어 사용법을 배워 명시된 목적을 달성할 수 있는 정도
3. **운영 용이성 (Operability)**: 시스템이 쉽게 조작하고 제어할 수 있는 속성을 갖는 정도
4. **사용자 오류 방지성 (User error protection)**: 시스템이 사용자로 하여금 오류를 범하지 않게 하는 정도
5. **사용자 인터페이스 심미성 (User interface aesthetics)**: 사용자 인터페이스가 사용자에게 만족스러움을 주는 정도
6. **접근성 (Accessibility)**: 사용자의 특성이나 능력(연령과 장애)에 관계없이 시스템을 사용할 수 있는 정도

--

## 사용성 평가 방법

현재 사용성 평가를 위한 다양한 방법들이 개발되어 있으며, 주요 방법은 다음과 같습니다:

### 1. **휴리스틱 평가 (Heuristic Evaluation)**
- 사용성 평가 전문가가 제품과 관련된 사용성 원칙을 기준으로 체크리스트를 통해 문제점을 도출하는 방법
- 비교적 적은 인원의 전문가(3명~5명)를 활용하여 빠르고 효율적으로 수행 가능
- 중요한 사용성 문제를 많이 도출할 수 있음

### 2. **FGI (Focus Group Interview)**
- 그룹 인터뷰 방법으로, 주로 시스템 개발 이전에 사용자 요구사항을 파악하는 데 사용되는 정성적 평가 방법
- 공통점이 있는 사용자들을 그룹별(7~8명)로 모아 의견을 나누고 정보를 수집

### 3. **인지적 워크쓰루 (Cognitive Walk-through)**
- 학습 용이성 분석에 중점을 둔 방법으로, 실제 사용자를 대상으로 사전 설명 없이 제품을 사용하여 과제를 달성하도록 한다
- 과제를 수행하는 각 단계에서 사용자가 올바른 행동을 취하는지 분석
- 평가자는 다음과 같은 질문을 던진다:
    - 사용자는 원하는 목적을 달성하기 위해 이 액션을 시도할 것인가?
    - 사용자가 올바른 액션을 수행하기 위해 필요한 컨트롤이 가시적인가?
    - 이 액션을 통해서 사용자가 과제를 달성할 수 있는지 알아낼 수 있는가?
    - 사용자는 적절한 피드백을 얻는가?

--

## 사용성 평가 주기

- 사용성 평가는 시스템 개발의 전 주기에 걸쳐 진행되어야 하며, 평가 목적에 따라 평가 방법을 달리하는 것이 좋습니다.
- 사용성 평가 결과에서 나타난 문제의 원인을 체계적으로 분석하고 시스템 개선에 반영하면, 이용자의 만족도를 높이는 시스템을 설계할 수 있습니다.


--

# 4.6 신뢰성 테스트

--

## 신뢰성 정의

**신뢰성 (Reliability)**은 특정 조건에서 특정 기간 동안 시스템이 요구되는 서비스를 오동작 없이 제공하는 정도를 의미합니다.

ISO 25010에서는 신뢰성을 다음 네 가지 부특성으로 설명하고 있습니다:

1. **성숙성 (Maturity)**: 시스템 또는 구성 요소가 정상 작동 상태에서 신뢰성 요구를 충족시키는 정도
2. **가용성 (Availability)**: 사용자가 시스템 또는 구성 요소를 사용하고자 할 때 사용 및 접근이 가능한 정도
3. **결함 허용성 (Fault tolerance)**: 하드웨어나 소프트웨어에 결함이 있어도 시스템이나 구성 요소가 의도한 대로 작동하는 정도
4. **복구성 (Recoverability)**: 중단 또는 장애가 발생한 경우 시스템이 영향을 받은 데이터를 복구하고 상태를 재설정할 수 있는 정도

--

## 신뢰성 척도

- **가용성 (Availability)**: 시스템이 주어진 기간 동안 서비스를 실제로 제공할 수 있는 정도를 나타내는 속성입니다.
    - 예: 가용성이 0.995인 시스템은 1000시간 동안 995시간을 서비스 제공할 수 있습니다.
  
- **MTTF (Mean Time To Failure)**: 시스템이 운영된 후 오류가 발생할 때까지 걸리는 평균 동작 시간입니다.
    - 예: MTTF가 100시간인 시스템은 평균적으로 100시간마다 1개의 오류가 발생할 수 있음을 의미합니다.

--

## 신뢰성 테스트 방법

### 1. **통계적 테스트 (Statistical testing)**

- 신뢰성을 테스트하기 위해 **운영 프로파일 (Operational profile)**을 사용하여 테스트 케이스를 생성합니다.
- 운영 프로파일은 가능한 입력들을 여러 개의 클래스로 분류하고, 각 클래스의 발생 확률로 구성됩니다.
  
### 2. **운영 프로파일 작성**

- 운영 프로파일은 실제 사용자들이 시스템을 사용하는 패턴을 반영하여, 각 입력 클래스의 발생 확률에 따라 테스트 케이스를 생성합니다.
  
### 3. **신뢰성 추정**

- 소프트웨어의 신뢰성을 측정하기 위해 오류 발생 시간과 오류 발생 후 다음 오류까지 걸린 시간을 기록합니다.
- 여러 신뢰성 추정 모델을 사용하여 수집된 데이터를 기반으로 신뢰성을 추정합니다.

--

# 4.7     보안성  테스트

## 보안성 정의

**보안성 (Security)**은 시스템이 정보 및 데이터를 보호하는 정도를 의미하며, 다음과 같은 다섯 가지 부특성으로 설명됩니다:

1. **기밀성 (Confidentiality)**: 접근 권한이 있는 사람에게만 데이터에 액세스할 수 있도록 하는 정도
2. **무결성 (Integrity)**: 시스템 또는 구성 요소가 컴퓨터 프로그램 또는 데이터에 무단으로 접근하거나 변경되는 것을 방지하는 정도
3. **부인 방지성 (Non-repudiation)**: 사건 및 행위 후에 부인하지 못하도록 행동 및 사건에 관해 입증할 수 있는 정도
4. **책임성 (Accountability)**: 각 개인을 유일하게 식별하여 행위를 기록하고, 필요 시 그 행위자를 추적할 수 있는 능력
5. **인증성 (Authenticity)**: 사건 및 행동에 관해 실제 행위자임을 증명할 수 있는 정도

--

## 보안성 검증 방법

### 1. **침입 테스트 (Penetration Test)**

- 침입 테스트는 해커의 관점에서 시스템의 취약성을 찾아내는 테스트 방법입니다.
- **장점**: 실제 침입자 시나리오를 기반으로 취약점을 발견하고 해결책을 제시할 수 있습니다.
- **주의사항**: 침입 테스트로 발견된 취약점이 없다고 해도 시스템의 보안성이 확립되었다고 보장할 수 없습니다. 침입자는 새로운 시나리오를 만들어낼 수 있기 때문입니다.

### 2. **정적 분석 (Static Analysis)**

- **정적 분석**은 보안성 높은 소프트웨어가 준수해야 할 코딩 규칙을 정의하고, 이를 코드 수준에서 검사하는 방법입니다.
- 정적 분석 도구를 사용하여 소스 코드의 보안성을 점검합니다.

### 3. **CWE (Common Weakness Enumeration)**

- **CWE**는 소스 코드에서 발생할 수 있는 신뢰성 및 보안성과 관련된 코딩 규칙을 정의한 목록입니다.
    - **CWE-658**: C 언어에 대한 보안 규칙, 예: Stack overflow, Buffer overflow, Null pointer dereference
    - **CWE-659**: C++ 언어에 대한 보안 규칙, 예: Uncaught exception, Catching generic exceptions
    - **CWE-660**: Java 언어에 대한 보안 규칙, 예: Unsafe JNI 사용, Public clonable() 메서드
    
- **방위사업청**에서 제시한 '무기체계 소프트웨어 개발 및 관리 매뉴얼'에서는 **CWE-658**, **CWE-659**, **CWE-660**을 기반으로 한 정적 시험을 명시하고 있습니다.


--
# 4.8     유지보수성  테스트
--

## 유지보수성 정의

**유지보수성 (Maintainability)**은 시스템이 변경 요구를 만족시키는 능력을 의미하며, 이를 테스트하는 것이 **유지보수성 테스트**입니다. 시스템 수정 요구는 다음과 같은 이유로 발생합니다:

1. **기능 개선 및 추가**: 기능이나 성능을 개선하거나 새로운 기능을 추가하기 위한 시스템 수정. 전체 수정 작업의 약 50%를 차지합니다.
2. **변경된 환경에 적응**: 운영체제, 인프라, 환경의 변화에 맞게 시스템을 수정하는 작업으로, 수정 작업의 약 25%를 차지합니다.
3. **오류 수정**: 소프트웨어 오류 발견 후 이를 수정하는 작업으로, 수정 작업의 약 20%를 차지합니다.
4. **예상치 못한 장애 예방**: 장애가 발생하지 않도록 코드 재구성이나 문서 갱신을 미리 수행하는 작업으로, 수정 작업의 약 5%를 차지합니다.

--

## 유지보수성 테스트 방법

유지보수성 테스트는 요구사항을 만족하도록 얼마나 쉽게 시스템을 변경할 수 있는지 테스트하는 과정으로, **정적 테스트**가 주로 사용됩니다. 물론, 수정 요구사항이 변경에 소요되는 시간이나 비용으로 표현되면 **동적 테스트**를 통해 실제 시간이나 비용을 계산하여 요구사항과 비교할 수 있습니다.

--

## ISO 25010의 유지보수성 세부 항목

ISO 25010에서는 유지보수성을 **모듈성**, **분석성**, **재사용성**, **변경 용이성**, **테스트 용이성**으로 세분화합니다. 이 중 모듈성, 분석성, 재사용성, 변경 용이성은 공통적인 특성이 많기 때문에 한꺼번에 다루어도 되지만, **테스트 용이성**은 다른 특성이므로 별도로 설명합니다.

--

## 모듈성, 분석성, 재사용성, 변경 용이성 테스트

이 특성들을 테스트하기 위해서는 다음과 같은 요소들을 검토해야 합니다:

- **모듈화 정도**
- **모듈 간 결합도**
- **모듈 응집도**
- **모듈 복잡도**

### 모듈화

시스템을 여러 부분으로 분할하여 각 부분이 정의된 기능을 잘 수행하도록 하는 설계 기법입니다. 모듈화를 측정하는 척도에는 **fan-in**과 **fan-out**이 있습니다:

- **Fan-in**: 얼마나 많은 모듈이 주어진 모듈을 호출하는지 나타냅니다.
- **Fan-out**: 주어진 모듈이 호출하는 다른 모듈 수를 나타냅니다.

--

## 모듈 구조도 예시

![그림 4.4  모듈 구조도](csts/images/csts_4.4.png)

시스템이 그림 4.4와 같이 모듈화되었을 때, **모듈 F**의 **fan-in**과 **fan-out**을 계산해 보겠습니다.

- **Fan-in**: 모듈 F를 호출하는 모듈은 B와 C 2개이므로, **fan-in은 2**입니다.
- **Fan-out**: 모듈 F가 호출하는 모듈은 I, J, L이므로, **fan-out은 3**입니다.

가장 문제시되는 모듈은 **fan-in**과 **fan-out**이 높은 모듈입니다. 이 모듈이 변경되면 많은 모듈에 영향을 미치며, 해당 모듈이 의존하는 모듈 중 하나라도 변경되면 그 모듈도 영향을 받습니다. 이러한 모듈은 **정적 분석**을 통해 식별하고 재구성해야 합니다.

--

## 결합도 (Coupling)

모듈 간의 **결합도**는 가능한 한 낮게 설계해야 합니다. 결합도가 높다는 것은 모듈이 의존하는 다른 모듈들이 변경될 때 영향을 받을 가능성이 크다는 의미입니다. 따라서 모듈 간 상호작용은 **잘 정의된 인터페이스**를 통해 이루어져야 하며, 공통 자료 영역이나 실행 흐름을 변경하는 제어요소를 통해 상호작용하는 것은 피해야 합니다.

--

## 응집도 (Cohesion)

**모듈의 응집도**는 각 모듈을 구성하는 요소들이 얼마나 서로 관련되어 있는지를 나타냅니다. 응집도가 높을수록 좋으며, **높은 응집도**를 가진 모듈은 다른 모듈에 의존 관계가 적어 **재사용성이 높고**, 변경이나 오류를 **국부화**할 수 있습니다.

--

### 객체지향 프로그램에서 응집도

객체지향 프로그램에서 클래스의 응집도를 나타내는 대표적인 척도는 **LCOM (Lack of Cohesion in Methods)**입니다. LCOM은 클래스 내의 메소드들이 얼마나 서로 연관되어 있는지를 나타내며, 여러 버전이 있습니다. 그 중 **LCOM4**는 클래스 내의 메소드들이 동일한 필드에 접근하거나 호출 관계가 있으면 연관되어 있다고 간주합니다. 

- 모든 메소드가 연관되어 있으면, 클래스가 하나의 기능(책임)을 수행하도록 설계된 것으로 간주됩니다.
- 만약 서로 연관되지 않은 메소드가 2개 이상 있으면, 이를 다른 클래스로 분할할 필요가 있습니다.

--

## 모듈화 및 응집도, 결합도, 복잡도, 테스트 용이성

![그림 4.5  예제 클래스](csts/images/csts_4.5.png)

그림 4.5의 **Foo 클래스**를 예로 들면, A() 메소드와 A1(), A2(), A3()가 호출 관계로 연결되어 있으며, B() 메소드와 B1(), B2() 메소드가 동일한 필드에 접근하고, C() 메소드와 C1(), C2(), C3()가 호출 관계로 연결되어 있다고 할 때, **LCOM(Foo) = 3**입니다. 

이는 **3개의 독립된 기능**을 하나의 클래스에서 제공한다고 간주하며, 이들은 각기 다른 **3개의 클래스로 분할할 필요**가 있음을 의미합니다.

--

## 모듈의 복잡도

**모듈의 복잡도**는 유지보수성에 영향을 미칩니다. **순환 복잡도**는 대표적인 복잡도 척도입니다. **RIAC (Reliability Information Analysis Center)**에서 발표한 복잡도와 소프트웨어 신뢰성과의 관계에 따르면, 순환 복잡도가 **75 이상**이면 결함을 수정하기 위해 수행한 작업이 새로운 결함을 발생시킬 가능성이 매우 크다고 합니다. 

따라서, 정적 분석을 통해 **순환 복잡도가 높은 모듈**을 식별하고, 이를 **리팩토링** 및 **재구성**하여 복잡도를 낮추는 것이 중요합니다.

--

## 테스트 용이성

**테스트 용이성**은 프로그램을 얼마나 손쉽게 테스트할 수 있는지 나타내는 특성입니다. 프로그램의 테스트 용이성을 높이기 위해 다음과 같은 특성을 고려하여 테스트를 수행합니다.

| 특성         | 설명                                                       |
|--------------|------------------------------------------------------------|
| **독립성**   | 테스트가 다른 모듈이나 시스템에 의존하지 않도록 설계되어야 함  |
| **일관성**   | 테스트의 결과가 항상 일관되게 나타날 수 있도록 설계되어야 함  |
| **유지보수성**| 테스트 케이스가 새로운 요구사항에 맞게 쉽게 수정될 수 있어야 함 |
| **완전성**   | 가능한 모든 경우를 테스트할 수 있어야 함                    |
| **자동화**   | 테스트가 자동으로 수행될 수 있어야 함                       |

![표 4.6  테스트 용이성](csts/images/csts_table_4.6.png)

--

# 4.9     이식성  테스트

## 이식성 테스트 개요

**이식성(Portability)** 테스트의 주요 목적은 **서비스 이용자 단말기의 하드웨어 및 소프트웨어 환경**이 달라도 **동등한 서비스를 제공하는지** 테스트하는 것입니다. 이식성 테스트는 **운영체제(OS)**, **브라우저**, **태블릿**과 **스마트폰** 등 **애플리케이션이 동작하는 운영 환경과 사용 환경**이 다양해지고 복잡해짐에 따라 점점 더 중요해지고 있습니다.

--

## 전자정부 서비스 예시

예를 들어, **우리나라 전자정부 서비스**를 생각해보겠습니다. 전자정부 서비스는 다양한 단말기나 브라우저 및 운영체제에서 동작하는 것이 매우 중요합니다. 행정안전부에서는 이를 고려하여 **전자정부 서비스 호환성 준수지침**을 제정하였고, **전자정부 서비스의 호환성 확보**를 위해 새로 개발되거나 유지보수되는 서비스에 대해 지켜야 할 사항을 규정하고 있습니다.

예를 들어, **행정안전부 고시 제2017-26호 개정판 4조**에서 **웹사이트 호환성 확보**에 대해 다음과 같이 언급하고 있습니다:

> 제4조【웹사이트 호환성 확보】  
> ① 행정기관 등의 장은 전자정부 서비스를 위한 웹사이트를 신규 개발하는 경우 다양한 웹 브라우저에서 동등하게 서비스를 제공하여야 한다.  
> ② 행정기관 등의 장은 전자정부 서비스를 위한 웹사이트를 개선, 유지보수 및 운영하는 경우 다양한 웹 브라우저에서 동등하게 서비스를 제공하도록 노력하여야 한다.  
> ③ 제1항 및 제2항에서 웹 브라우저의 종류는 해당 전자정부 서비스를 신규 개발, 개선, 유지보수 및 운영하는 행정기관 등의 장이 정한다.

--

## 전자정부 호환성 진단표

또한 **전자정부 호환성 진단표**를 제정하여 구체적인 진단 지표, 진단 기준, 방법까지 규정하고 있습니다. 아래는 **전자정부 서비스 웹 호환성 진단표**입니다.

| 진단 항목           | 진단 기준                            | 방법                                                       |
|--------------------|--------------------------------------|------------------------------------------------------------|
| **웹 브라우저 호환성**  | 다양한 웹 브라우저에서 서비스가 동등하게 제공되어야 한다. | 각 브라우저에서 웹사이트의 기능 및 UI 테스트를 수행한다.  |
| **운영체제 호환성**     | 다양한 운영체제에서 서비스가 동등하게 제공되어야 한다.   | Windows, macOS, Linux 등 다양한 운영체제에서 테스트를 진행한다. |
| **디바이스 호환성**     | 다양한 디바이스에서 서비스가 동등하게 제공되어야 한다.   | 스마트폰, 태블릿, 데스크탑 등 여러 디바이스에서 테스트를 진행한다. |

![표 4.7  전자정부 서비스 웹 호환성 진단표](csts/images/csts_table_4.7.png)

--

## 크로스 브라우징 테스트

**크로스 브라우징 테스트**는 **다양한 브라우저**에서 또는 동일한 브라우저이지만 버전이 서로 다른 브라우저에서 **대상 애플리케이션이 동일하게 동작하는지** 테스트하는 과정입니다. 

이 테스트가 중요한 이유는 **운영체제**나 **브라우저**에서 채택하는 **렌더링 엔진**이 다르기 때문에, 동일한 애플리케이션이 **브라우저마다 다르게 보일 수 있기** 때문입니다. 따라서 **크로스 브라우징 테스트**를 수행하는 작업은 매우 중요합니다.

--

## Selenium Grid를 사용한 자동화

**크로스 브라우징 테스트**를 자동화하기 위해 **Selenium Grid**, **QTP**, **RFP**와 같은 도구들을 사용할 수 있습니다. 이 도구들은 테스트 스크립트를 **다양한 브라우저와 운영체제 조합에서** 실행할 수 있도록 지원합니다.

### Selenium Grid 아키텍처

**Selenium Grid**는 **하나의 허브**와 여러 개의 **노드**로 구성되어 있으며, 다양한 운영체제 및 브라우저 환경을 갖춘 여러 노드를 통해 **허브에서 제공받은 테스트 스크립트**를 동시에 수행할 수 있는 **분산 테스트 실행 도구**입니다.

그림 4.6에 보여준 **Selenium Grid 아키텍처**에서는, 여러 노드에 분산된 테스트를 통해 **크로스 브라우징 테스트**를 수행할 수 있으며, **동일한 플랫폼**에서 노드가 있을 경우, 테스트 스크립트를 여러 노드에 분산 실행하여 **테스트 실행 시간을 단축**시킬 수 있습니다.

![그림 4.6  Selenium Grid 아키텍처](csts/images/csts_4.6.png)

--

## 자동화 도구의 한계

하지만 **크로스 브라우징 테스트**를 자동화 도구로 수행한다고 해서 모든 문제가 해결되는 것은 아닙니다. 실제 **인간의 눈**으로만 확인할 수 있는 부분이 존재하며, 이를 **자동화하기**란 매우 어려운 일입니다. 예를 들어, UI의 시각적 요소나 레이아웃의 정확한 구현 등을 자동화 도구로 정확히 체크하는 데는 한계가 있을 수 있습니다.

따라서 전적으로 자동화 도구에 의존하기보다는 **매뉴얼 테스트**를 병행적으로 수행하는 것이 좋습니다. **테스트 자동화**에 대한 구체적인 내용은 7장에서 더 자세히 다루어집니다.

--

Exercise

--

01   다음 중 사용자의 요구사항을 시스템이 얼마나 만족하는지에 대한 정보를 제공하는 기능 적합성 테스트의 부특성에 대한 설명으로 올바른 것은? 
① 완전성: 모든 명시된 기능을 시스템이 제공하는 정도
② 적절성: 기능 수행 시 사용되는 자원이 요구사항을 만족시키는 정도
③ 정확성: 사용자의 목적 달성에 소프트웨어가 도움을 주는 정도
④ 가용성: 사용자가 원하는 시간에 사용 및 접근이 가능한 정도

해설 :
① 완전성: 모든 명시된 기능을 시스템이 제공하는 정도
② 적절성: 사용자의 목적 달성에 소프트웨어가 도움을 주는 정도
③ 정확성: 정의된 정밀도에 따라 정확하게 결과를 제공하는 정도
④ 가용성: 신뢰성의 부특성

--

02   다음 중 성능 효율성 테스트의 부특성은 무엇인가?

① 운영 용이성
② 자원 활용성
③ 상호 운영성
④ 복구성
해설 :
성능 효율성 테스트 부특성: 시간 반응성(Time-behaviour), 자원 효율성(Resource Utilization), 수용성(Capacity)
① 운영 용이성: 사용성 테스트 부특성 ③ 상호 운영성: 호환성 테스트 부특성 ④ 복구성: 신뢰성 테스트 부특성

--

03   다음 그림에서 스파이크 테스팅에 해당하는 것은?

![c4.ex03](csts/images/csts_4.ex03.png)
해설 :
이 테스팅은 짧은 시간에 사용자가 몰릴 때 시스템의 반응을 측정한다. BTS와 같은 세계적인 아이돌 
그룹의 공연 예매를 지원하는 시스템에 짧은 시간에 수많은 사용자가 몰리는 상황을 생각해볼 수 있다.

--
정답   01 ①  02 ②  03 ③

--

04 서로 다른 시스템과의 상호연동능력을 확인하기 위한 테스트로, 테스트하고자 하는 제품 이 다른 제품과 공통으로 환경 및 자원을 공유하면서 그 제품에 유해한 영향을 미치지 않 고 올바른 기능을 수행할 수 있는지 확인하는 테스트는 이식성 테스트이다.[○/×]

해설 :
서로 다른 시스템과의 상호연동능력을 확인하기 위한 테스트로, 테스트하고자 하는 제품이 다른 제품과 공통으로 환경 및 자원을 공유하면서 그 제품에 유해한 영향을 미치지 않고 올바른 기능을 수행할 수 있는지 확인하는 테스트는 호환성 테스트이다.

--

05   다음은 ISO/IEC 25010 품질 특성에 관한 설명이다. 어떤 품질 특성에 대한 설명인지 기술 하시오.
특정 조건에서 특정 기간 동안 오동작 없이 의도된 기능을 수행하는 소프트웨어의 능력을 말 하며, 부특성으로는 성숙성, 가용성, 결함 허용성, 복구성이 있다. 

해설 :
신뢰성에 대한 설명이다. 

--

06   보안성 품질 특성에 대한 설명으로 가장 적절한 것은?
① 보안성의 부특성은 성숙성, 가용성, 접근성이 있다.
② 소프트웨어가 정보 및 데이터를 올바르게 보호하는 능력을 의미한다.
③ 보안성 결함은 명세 및 구조 기반 테스팅 기법으로 모두 검출할 수 있다.
④ 부특성인 접근성은 데이터가 인가되지 않은 접근으로부터 보호되는 비율, 암호화 및 복호 화가 정확히 구현된 비율 등으로 측정한다.

해설 :
① 보안성의 부특성은 기밀성, 무결성, 부인 방지성, 책임성, 인증성이다.
③ 보안성 결함은 일반적인 테스팅 기법으로 검출할 수 없으므로 침투 시험 (Penetration Test)를 수 행하여 보안의 취약점을 확인한다.
④ 보안성의 부특성 중 기밀성에 대한 설명이다.

--
07   프로그램이 얼마나 손쉽게 테스트 가능한지를 나타내는 특성과 가장 거리가 먼 것은?
① 단순성(Simplicity)
② 관찰 용이성(Observability)
③ 운용 용이성(Operability)
④ 견고성(Robustness)
해설 :
견고성은 테스트 용이성과 가장 거리가 먼 특성이다. 반면에 단순성, 관찰 용이성, 운용 용이성은 테스 트 용이성의 구체적인 특성이다
--

정답   04 ×  05 신뢰성(Reliability)  06 ②  07 ④

--

08   다음은 어떤 품질 특성을 평가하는 방법인가?
∙ 인지적 워크쓰루(Cognitive walk-through)
∙ FGI(Focus Group Interview)
∙ 휴리스틱 평가(Heuristic Evaluation)

① 사용성 ② 호환성 ③ 유지보수성 ④ 신뢰성

해설 : 모두 사용성을 평가하는 방법이다.

--

09   다음은 프로그램을 얼마나 손쉽게 테스트할 수 있는지를 나타내는 테스트 용이성에 관한 설명이다. 특성과 설명이 올바르게 연결된 것은?

(가) 제어 용이성 (나) 안정성 (다) 분할 용이성 (라) 이해 용이성
Ⓐ 테스트 동안에 소프트웨어에 대한 변경이 자주 발생하지 않도록 설계 
Ⓑ 소프트웨어 설계 정보가 잘 조직화되어 쉽게 접근 가능하도록 설계 
Ⓒ 테스트할 대상 영역을 제어함으로써 문제가 발생된 곳을 고립시켜 독립적으로 모듈 시험
Ⓓ 프로그램의 실행을 제어하기 용이하도록 설계

① (가)―Ⓓ, (나)―Ⓐ, (다)―Ⓒ, (라)―Ⓑ
② (가)―Ⓓ, (나)―Ⓑ, (다)―Ⓒ, (라)―Ⓐ
③ (가)―Ⓒ, (나)―Ⓐ, (다)―Ⓓ, (라)―Ⓑ
④ (가)―Ⓒ, (나)―Ⓑ, (다)―Ⓓ, (라)―Ⓐ

해설 :
(가) 제어용이성：프로그램의 실행을 제어하기 용이하도록 설계
(나) 안정성：테스트 동안에 소프트웨어에 대한 변경이 자주 발생하지 않도록 설계
(다) 분할용이성：테스트할 대상 영역을 제어함으로써 문제가 발생된 곳을 고립시켜 독립적으로 모듈 시험
(라) 이해용이성：소프트웨어 설계 정보가 잘 조직화되어 쉽게 접근 가능하도록 설계

--
정답   08 ①  09 ①

