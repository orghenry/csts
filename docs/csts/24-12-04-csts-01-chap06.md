# 제 6 장 소프트웨어 생명 주기 모델과 테스트

## 6.1 소프트웨어 생명 주기 개요
소프트웨어 생명 주기는 소프트웨어 개발 과정을 **순차적** 또는 **병렬적** 단계로 체계화한 **추상적 표현**입니다. 

### 전형적인 개발 방법
1. **요구사항 분석**: 분석가가 요구사항을 수집하고 문제를 이해 및 분석.
2. **설계 단계**: 시스템과 모듈 구조를 설계.
3. **구현 단계**: 설계된 모듈을 코딩하여 시스템을 완성.

--

### 유연한 개발 방식
소프트웨어 개발은 상황에 따라 다양한 방식으로 진행될 수 있습니다:
- **소규모 프로젝트**: 별도의 분석이나 설계 과정 없이 바로 코딩 시작 가능.
- **디버깅 중심 개발**: 테스트 작업을 별도로 수행하지 않고 디버깅의 일부로 처리.

#### Code-and-Fix 모형
- 요구사항 분석이나 설계 없이 바로 코딩하고, 디버깅 중심으로 진행하는 개발 방식.
- **장점**: 단기 프로젝트나 폐기용 소프트웨어에 적합.
- **단점**: 장기간 사용되거나 대규모 시스템에서는 유지보수와 품질 관리에 비효율적.

--

## 6.2 소프트웨어 생명 주기 모형과 테스트의 역할
다양한 **소프트웨어 생명 주기 모델**은 개발 방식에 따라 테스트의 역할과 위치를 다르게 정의합니다. 
이 장에서는 **주요 생명 주기 모델**들을 살펴보고, 각 모델에서 테스트가 어떻게 작동하는지 설명합니다.


--
## 6.1 순차적 개발 모델

### 폭포수 모델
폭포수 모델은 가장 오래된 전통적인 소프트웨어 생명 주기 모델로, **체계적이고 순차적인 접근 방식**을 기반으로 합니다. 소프트웨어 개발 과정을 다음과 같은 주요 단계로 나눕니다:

1. **요구사항 분석**: 시스템에 대한 요구사항을 명확히 정의.
2. **설계**: 요구사항을 기반으로 시스템 구조 설계.
3. **코딩**: 설계를 구현하여 소프트웨어를 개발.
4. **테스트**: 코딩된 소프트웨어를 검증.
5. **유지보수**: 소프트웨어 배포 후 문제를 수정하고 개선.

### 특징
- 각 단계가 완료된 후에야 다음 단계로 진행.
- 이전 단계로 돌아가 수정하기 어렵기 때문에 **사전 계획**과 **명확한 요구사항**이 중요.

--

### 그림 6.1 폭포수 모델
![그림 6.1 폭포수 모델](csts/images/csts_6.1.png)

### 폭포수 모델의 테스트 역할
- **독립적 테스트 단계**: 모든 코딩이 완료된 후에 진행.
- **단점**: 
  - 테스트 단계 이전에는 결함 발견이 어렵고, 초기 결함 발견 시 비용이 증가.
  - 유연성이 부족하여 변경 요구 사항 반영이 제한적.

### 활용 사례
- 요구사항이 **명확하고 변하지 않는 경우**에 적합.
- 대규모 프로젝트보다는 **작고 단순한 프로젝트**에 효과적.

--
### 폭포수 모델 주요 단계

#### 1. 요구사항 분석
- **내용**: 개발하려는 소프트웨어에 대한 요구사항을 수집하고 문제를 분석 및 명세화.
- **주요 작업**:
  - 요구되는 기능, 성능, 인터페이스 파악.
  - 소프트웨어 특성 정의.
- **산출물**: 요구사항 명세서 (Requirements Specification).

#### 2. 구조 설계
- **내용**: 소프트웨어의 전체적인 구조를 결정.
- **주요 작업**:
  - 시스템 구성 요소(모듈, 데이터베이스 등) 간의 의존성 파악.
  - 구성 요소 간 상호 연결 설계.
- **산출물**: 설계 명세서 (Architectural Design Specification).

--

#### 3. 상세 설계
- **내용**: 각 모듈의 세부 사항 설계.
- **주요 작업**:
  - 알고리즘, 데이터 표현, 모듈 간 인터페이스 설계.
- **산출물**: 상세 설계 명세서 (Detailed Design Specification).

#### 4. 코딩
- **내용**: 소프트웨어를 프로그래밍 언어로 구현.
- **주요 작업**:
  - 설계 명세서를 기반으로 코드 작성.
- **산출물**: 완성된 프로그램.

#### 5. 테스팅
- **내용**: 완성된 소프트웨어의 결함을 검출 및 수정.
- **주요 작업**:
  - 요구사항에 따라 기능 검증.
  - 결함 식별 및 수정.
- **산출물**: 테스트 결과 보고서.

--

### 폭포수 모델의 적합성
- **적합한 경우**:
  - 사용자의 요구사항이 명확하고 변하지 않을 때.
  - 개발자가 요구사항에 익숙할 때.
- **부적합한 경우**:
  - 요구사항이 개발 중 변경될 가능성이 높은 경우.


--
### 폭포수 모델과 테스트의 관계

#### 폭포수 모델의 테스트 장점
- **문서 기반**: 개발 과정에서 산출된 많은 문서와 정보로 인해 코딩 후 테스트에 필요한 자료 확보가 용이.
- **단계적 접근**: 테스트를 독립적인 개발 단계로 명확히 수행.

#### 폭포수 모델의 테스트 한계
- **테스트 시점 지연**: 테스트 작업을 코딩 완료 후에 수행함으로써 결함 발견 시점이 늦어질 수 있음.
- **결함 수정 비용 증가**:
  - 초기 단계에서 결함 발견 시보다, 후반 단계에서 발견 시 비용과 시간이 더 많이 소요.
  - 구조 설계상의 본질적 문제가 개발 완료 시점에서 수정이 불가능할 수도 있음.
- **프로젝트 위험 증가**: 결함 발견 및 수정 지연이 전체 비용과 일정에 심각한 영향을 미침.

--

### V-모델 소개

#### 개념
- V-모델은 **개발과 테스트를 동등하게 취급**하며, 테스트를 소프트웨어 생명 주기의 모든 단계에서 고려하는 모델.
- 개발 중심의 폭포수 모델과 달리 **개발 단계와 테스트 단계**를 병행하여 상호 연계.

#### V-모델의 특징
- **단계 구분**:
  - **왼쪽(V의 왼쪽)**: 개발 관련 단계 (Software Development Life Cycle, SDLC).
  - **오른쪽(V의 오른쪽)**: 테스트 관련 단계 (Software Testing Life Cycle, STLC).
- **테스트의 조기 개입**: 각 개발 단계와 대응하는 테스트 계획이 존재하여 초기 단계에서부터 결함을 예방하고 검증.

--

### V-모델 다이어그램
**그림 6.2**: V-모델 구조를 설명하며, 왼쪽은 SDLC, 오른쪽은 STLC 단계를 보여줌.

![그림 6.2  V-모델](csts/images/csts_6.2.png)

### V-모델에서 테스트 활동

#### 테스트 활동의 초기 시작
- **테스트 계획 수립**:
  - **인수 테스트 계획**: 프로젝트 초기, 요구사항 수집 단계에서 작성.
  - **시스템 테스트 계획**: 단위 및 통합 테스트가 끝나길 기다릴 필요 없이 조기에 수립 가능.
- **개발 산출물 활용**:
  - **인수 테스트**: 사용자의 요구사항에 따라 테스트 케이스 작성.
  - **통합 테스트**: 구조 설계도 기반으로 테스트 케이스 작성.

--

### 테스트 레벨별 역할
- **단위 테스트**:
  - **목적**: 각 모듈이 개별적으로 올바르게 기능을 수행하는지 확인.
  - **활용 자료**: 상세 설계 명세 및 구현 정보.
- **통합 테스트**:
  - **목적**: 모듈 간 인터페이스 및 의존성 테스트.
  - **활용 자료**: 모듈 의존성을 보여주는 구조 설계 문서.
- **시스템 테스트**:
  - **목적**: 통합된 시스템이 시스템 명세서에 따라 동작하는지 검증.
  - **수행 주체**: 개발자.
- **인수 테스트**:
  - **목적**: 사용자의 요구사항에 부합하는지 사용자 관점에서 확인.
  - **특징**: 결함 검출보다는 요구사항 준수 여부에 중점.

--

### 정적 테스트
- **대상**:
  - 요구사항 명세서.
  - 구조 설계 명세서.
  - 상세 설계 명세서.
  - 소스 코드.
- **방법**:
  - **리뷰**: 산출물을 검토하여 결함 검출.
  - **정적 분석**: 도구를 활용하여 코드 결함 및 잠재적 문제 탐지.

--

### V-모델의 테스트 장점
- 테스트를 **개발과 병행**하여 초기 단계에서 결함을 조기에 발견.
- 동적 테스트와 정적 테스트를 모두 포함하여 결함 검출 범위 확대.

--
### 심화 노트: 폭포수 모델과 V-모델


#### 폭포수 모델과 V-모델의 주요 차이점
1. **개발과 테스트의 관계**:
   - **폭포수 모델**: 테스트는 코딩이 끝난 후에 단일 단계로 수행.
   - **V-모델**: 개발 단계와 테스트 계획/설계가 병행하여 진행.

2. **테스트 계획 및 설계 시점**:
   - **폭포수 모델**: 코딩이 완료된 후 테스트 활동 시작.
   - **V-모델**: 프로젝트 초기에 테스트 계획 및 설계 활동 시작.

--

#### V-모델에서 V의 의미: V&V
- **Verification (검증)**:
  - **정의**: 시스템이 명세를 만족하는지 확인.
  - **핵심 질문**: *"Are we building the system right?"*
  - **예시**:
    - 시스템 명세, 구조 설계, 상세 설계가 각 단계별 테스트를 통해 검증됨:
      - 단위 테스트, 통합 테스트, 시스템 테스트.

- **Validation (확인)**:
  - **정의**: 시스템이 사용자의 요구사항을 만족하는지 확인.
  - **핵심 질문**: *"Are we building the right system?"*
  - **예시**:
    - 인수 테스트: 사용자의 의도대로 시스템이 구현되었는지 확인.

--

#### V-모델의 테스트 유형별 분류
- **검증(Verification)**:
  - **목적**: 명세와 구현의 일치 여부 확인.
  - **방법**: 단위 테스트, 통합 테스트, 시스템 테스트.
  - **적용 대상**:
    - 시스템 명세, 구조 설계, 상세 설계 등.

- **확인(Validation)**:
  - **목적**: 사용자 요구사항 충족 여부 확인.
  - **방법**: 인수 테스트.
  - **특이 사항**: 사용자 운영환경 정보가 반영된 시스템 테스트도 확인으로 간주 가능.

--

#### 핵심 비교
- 폭포수 모델:
  - **테스트 시점**: 개발 완료 후.
  - **테스트 역할**: 후속 단계로 간주.
- V-모델:
  - **테스트 시점**: 개발과 병행.
  - **테스트 역할**: 개발과 동등하게 취급.

V-모델은 테스트를 조기에 계획하고 개발과 병행하여 결함을 신속히 발견함으로써 프로젝트의 품질과 비용 효율성을 높인다.


--
### 6.2 진화적 개발 모델

#### 진화적 개발 모델의 개요
- **적용 배경**:
  - 프로젝트 초기부터 **모든 요구사항이 명확하지 않은 경우** 적합.
  - **요구사항 변경이 빈번히 발생**하는 환경에서 효과적.
- **한계**:
  - 순차적 개발 모델은 요구사항이 초기에 완전히 정의된 경우에만 적합.

--

#### 주요 원칙
1. **이터레이션(Iteration)**:
   - 소프트웨어 개발을 **여러 반복 단계**로 나눠 진행.
   - 각 이터레이션 후 **고객 피드백**을 통해 개선.

2. **점진적(Incremental) 개발**:
   - 시스템의 **핵심 기능부터 개발**한 후, 점차적으로 구성요소와 요구사항을 추가.
   - **완전한 최종 시스템**에 도달할 때까지 지속적으로 확장.

--

#### 진화적 개발의 과정
1. **초기 개발**:
   - 시스템의 **핵심 구성요소** 개발 및 구현.
   - 첫 번째 이터레이션 결과물을 고객에게 제공.

2. **고객 평가**:
   - 고객이 결과물을 사용하고 피드백 제공.

3. **피드백 반영 및 개선**:
   - 요구사항 변경 및 추가사항 반영.
   - 다음 이터레이션에서 개선 작업 수행.

4. **최종 완성**:
   - 반복 작업을 통해 **최종 완성품** 도출.

--

#### 그림 6.3 진화적 개발 모델
![그림 6.3 진화적 개발 모델](csts/images/csts_6.3.png)

--

#### 진화적 개발 모델의 특징
- **장점**:
  - 초기 단계에서 요구사항이 불완전하더라도 개발 시작 가능.
  - 고객 피드백을 통해 점진적으로 시스템 품질 향상.
  - 변경 요구사항에 대한 유연한 대응.

- **단점**:
  - 개발 과정이 길어질 수 있어 **시간과 비용 관리**가 필요.
  - 반복적인 작업으로 인해 **복잡성 증가** 가능성.

진화적 개발 모델은 고객의 피드백을 지속적으로 반영하여 소프트웨어를 점진적으로 완성시키는 유연한 접근 방식을 제공한다.

#### 진화적 개발 모델의 테스트 프로세스

진화적 개발 모델은 **각 이터레이션**에서 **테스트 수행 계획**을 작성하고, 이 계획에 따라 테스트를 체계적으로 진행한다. 

--

#### 이터레이션 내 테스트 단계
1. **요구사항 분석 및 설계 단계 테스트**:
   - 테스트 대상: 요구사항 문서, 설계 문서.
   - **정적 테스트** 수행:
     - **리뷰 및 검토**:
       - 문서 기반 위험 분석을 통해 위험도를 평가.
       - 위험도에 따라 검토 방법 선정.
     - **정적 분석**:
       - 도구를 사용하여 문서에서 결함을 자동 검출.
   - **목적**:
     - 구현 전에 결함을 발견하여 조기 수정.
     - 개발 후반부에 결함 발견 시 초래할 **위험 및 비용 증가 최소화**.

--

2. **코드 구현 이후 테스트**:
   - **컴포넌트(단위) 테스트**:
     - 개별 모듈이 명세에 따라 올바르게 작동하는지 확인.
   - **통합 테스트**:
     - 모듈 간의 상호작용 및 의존성 점검.
   - **시스템 테스트**:
     - 전체 시스템이 명세에 따라 작동하는지 검증.
   - **비기능 테스트(선택적)**:
     - 성능, 안정성, 보안 등 비기능적 요구사항 확인.

--

#### 정적 테스트와 동적 테스트의 연계
- **정적 테스트**:
  - 구현 이전, 문서 기반 검토를 통해 결함 검출.
- **동적 테스트**:
  - 코드 작성 후 실행 기반 테스트.
- **장점**:
  - 정적 테스트로 초기에 결함을 발견함으로써 개발 후반부 리스크를 줄이고, 동적 테스트의 효과를 극대화.

--

#### 테스트 프로세스의 중요성
- **효율적인 위험 관리**:
  - 요구사항 및 설계 단계에서 리스크를 분석하고 조치.
- **품질 향상**:
  - 반복적 테스트 수행을 통해 **결함 예방** 및 **조기 발견**.
- **비용 절감**:
  - 초기에 결함을 수정하여 개발 후반부의 **수정 비용** 최소화.

진화적 개발 모델의 테스트 프로세스는 각 단계에서의 철저한 검증과 테스트를 통해 소프트웨어의 품질과 안정성을 보장한다.

--

## 나선형 개발 모델: 반복적⋅점진적 접근 방식


### 개요
나선형 개발 모델은 **요구사항이 불완전하거나 점진적으로 확장**되는 프로젝트에 적합한 모델로, **반복적(Iterative)**이고 **점진적(Incremental)**인 개발 방식을 채택한다. 

--

### 주요 특징
1. **프로토타입 기반 개발**:
   - 초기 단계에서 기술적으로 어렵거나 비즈니스 가치가 높은 요구사항을 우선 프로토타입으로 개발.
   - 사용자의 테스트 및 평가를 통해 프로토타입을 검토 및 개선.
   - 필요에 따라 기존 프로토타입을 확장하거나 폐기 후 재개발.

2. **위험 분석**:
   - 새로운 개발 주기가 시작될 때마다 잠재적인 위험 요소를 분석.
   - 위험 해결 방안을 개발 프로세스에 반영하여 안정성을 높임.

3. **사용자 피드백**:
   - 각 주기마다 사용자에게 결과물을 전달하여 평가와 피드백을 수집.
   - 피드백을 기반으로 요구사항을 정제하고 설계 및 테스트에 반영.

4. **메타 생명 주기 모델**:
   - 나선형 모델의 각 타원 주기에서 다른 생명 주기 모델(예: V-모델)을 혼합하여 활용 가능.
   - 유연한 개발 방법론으로, 상황에 맞는 프로세스 선택 가능.

--

### 나선형 모델의 단계
1. **계획(Planning)**:
   - 목표 설정, 자원 할당, 위험 분석 수행.
2. **위험 분석(Risk Analysis)**:
   - 잠재적 위험 요소를 식별하고 해결 방안을 모색.
3. **개발 및 검증(Development and Verification)**:
   - 프로토타입 또는 핵심 기능 개발.
   - 테스트를 통해 문제점 검증 및 수정.
4. **평가 및 피드백(Evaluation and Feedback)**:
   - 사용자와의 협력을 통해 개선 방향 설정.

--

### 장점
- **조기 결함 발견**:
  - 각 주기마다 적절한 테스트를 수행하여 초기 단계에서 문제점 발견 및 해결.
- **고객 중심 개발**:
  - 지속적인 사용자 평가와 피드백 반영을 통해 사용자 요구사항 만족.
- **유연한 설계**:
  - 요구사항 변경에 빠르게 대응 가능.
  - 필요에 따라 프로토타입 폐기 및 재개발.

--

### 그림 6.4 나선형 모형
![그림 6.4 나선형 모형](csts/images/csts_6.4.png)

--

### 나선형 모델의 테스트 관점
- **주기별 테스트 수행**:
  - 개발 단계에서 발생할 수 있는 문제를 조기 해결.
- **고객 평가 기반 테스트**:
  - 사용자 피드백을 다음 주기의 설계와 테스트에 반영.
- **위험 관리 중심 테스트**:
  - 위험 분석 결과를 기반으로 테스트 전략 수립.

--

### 폭포수 모델과의 비교
- **문제 해결 시점**:
  - 폭포수 모델: 개발 완료 후 결함 발견 가능성이 높음.
  - 나선형 모델: 각 주기마다 결함 검출 및 해결 기회 제공.
- **요구사항 변경 대응**:
  - 폭포수 모델: 요구사항 변경이 어렵고 비용 증가 가능성.
  - 나선형 모델: 점진적 확장과 반복을 통해 유연한 요구사항 반영.


나선형 개발 모델은 반복적이고 점진적인 접근 방식으로 **고객 중심의 품질 향상**과 **위험 감소**를 목표로 하는 개발 방법론이다.


--
### 6.3 애자일 개발 모델: 유연하고 민첩한 소프트웨어 개발 방식

--

### 애자일(Agile)의 기본 개념
- **'Agile'의 의미**: 빠르고 민첩하게 적응하는 소프트웨어 개발 방식을 의미하며, **전통적 폭포수 모델**과 같은 복잡하고 문서 중심적, 프로세스 위주의 방법론과 대비된다.
- **핵심 가치**: 애자일은 방법론보다는 소프트웨어 개발에서 우선시되는 **가치와 원칙**을 중심으로 한다.

--

### 애자일 개발의 4가지 핵심 가치
1. **사람 및 상호 의사 교환 > 프로세스와 도구**
   - 개발 과정에서 사람 간의 소통과 협력을 최우선으로 함.
   - 도구와 프로세스는 이를 지원하는 보조적인 역할.

2. **동작하는 소프트웨어 > 포괄적인 문서**
   - 완벽한 문서화보다 **실제로 작동하는 소프트웨어**를 개발 목표로 설정.
   - 문서화는 최소한으로 유지하며 실질적인 결과물을 우선시.

3. **고객과의 협력 > 계약 협상**
   - 고객과 지속적으로 소통하며 요구사항을 반영.
   - **계약 조건**보다 **고객의 실제 요구**를 충족시키는 데 중점을 둠.

4. **변화에 반응 > 계획 준수**
   - 초기 계획보다 **환경 변화**와 **새로운 요구사항**에 유연하게 대응.
   - 예측보다는 적응 능력을 중시.

--

### 애자일의 주요 특징
- **반복적 개발**:
  - 짧은 개발 주기(스프린트)를 반복하며 점진적으로 소프트웨어를 완성.
- **고객 중심**:
  - 고객의 피드백을 수용하여 지속적으로 개선.
- **팀워크 강조**:
  - 소규모 자율적인 팀이 소통과 협력을 통해 개발 주도.
- **작동하는 결과물 우선**:
  - 문서화보다는 실제 작동하는 소프트웨어를 목표로 개발.

--

### 애자일 방법론이 효과적인 경우
1. **불확실한 요구사항**:
   - 요구사항이 명확하지 않거나, 빈번히 변경되는 프로젝트에 적합.
2. **고객 피드백이 중요한 경우**:
   - 사용자와의 지속적인 상호작용이 요구되는 경우.
3. **빠른 출시 필요**:
   - 점진적으로 기능을 추가하면서 빠르게 배포가 필요한 경우.

--

애자일 개발 모델은 **변화에 민첩하게 대응**하고, **사람 중심의 협력**과 **작동하는 소프트웨어**를 통해 **고객 만족**을 최우선으로 한다.
### 애자일 선언 (Agile Manifesto)과 개발 접근 방식

--

### 애자일 선언(Agile Manifesto)
- 애자일 개발 방법론은 **4가지 핵심 가치**를 통해 기존의 개발 방법론과의 차별점을 강조합니다.
    1. **사람 및 상호 의사 교환 > 프로세스와 도구**
    2. **동작하는 소프트웨어 > 포괄적인 문서**
    3. **고객과의 협력 > 계약 협상**
    4. **변화에 반응 > 계획 준수**

이러한 가치는 애자일 개발이 추구하는 **고객 중심적이고 유연한 개발 방식**을 기반으로 합니다.

--

### 애자일 개발의 반복적이고 점진적인 접근 방식

- 애자일 방법론은 **진화적 개발 모델**과 유사하게 **반복적이고 점진적인 개발(Iterative and Incremental Development, IDD)**을 따릅니다.
  
#### IDD(Iterative and Incremental Development)
- 소프트웨어 개발을 여러 개의 **이터레이션**(Iteration)으로 나누어 진행합니다.
- 각 이터레이션은 **요구 분석, 설계, 구현, 테스트**와 같은 활동을 포함하는 **소규모 프로젝트**로 볼 수 있습니다.
- 각 이터레이션의 결과물은 **부분적으로 완성된 시스템**으로, **내부 개발자에 의해 관리**됩니다.
- 최종 릴리즈는 **최종 반복 주기의 산출물**만을 사용자에게 제공하며, 각 주기마다 새로운 **요구사항이 추가**되어 점진적으로 개발이 이루어집니다.

--

### 이터레이션 주기와 개발 방식
- **주기**: 각 반복 주기는 **1주에서 4주** 정도의 기간을 가집니다.
- **Incremental Development**: 매 이터레이션에서 새로운 요구사항을 **추가**하여 시스템을 **점진적으로 발전**시킵니다.

--

### 그림 6.5 - 애자일 방법에서의 IID
- 애자일 개발 방식에서는 각 이터레이션이 **작고 관리 가능한** 단위로 수행되며, 결과적으로 사용자가 필요한 기능을 점진적으로 제공할 수 있습니다.

애자일 방법론은 **반복적이고 점진적인 개발**을 통해 요구사항 변경에 유연하게 대응하고, 최종 제품을 사용자와의 협력을 바탕으로 지속적으로 개선해 나갑니다.

--

그림 6.5  애자일 방법에서의 IID
![그림 6.5  애자일 방법에서의 IID](csts/images/csts_6.5.png)

--
### 애자일 개발 모델의 특징: 빠른 피드백과 유연성

--

### 짧은 이터레이션과 빠른 피드백
- **짧은 이터레이션** 덕분에 고객은 순차적 개발 모델에서처럼 오랜 시간이 걸리지 않고 **실제 동작하는 소프트웨어**를 빠르게 볼 수 있습니다.
- 각 이터레이션이 완료될 때마다 **일의 진척도를 눈으로 확인**할 수 있는 기회가 많아집니다. 이는 **동작하는 소프트웨어가 포괄적인 문서보다 우선**한다는 애자일 선언의 핵심 원칙을 반영한 것입니다.

--

### 고객과의 협력과 요구사항 우선순위 설정
- 각 이터레이션에서 개발할 요구사항은 **고객이 각 반복 주기 시작 전에 선택**합니다. 고객은 일반적으로 **가장 높은 비즈니스 가치를 가져다주는 요구사항**을 우선순위로 설정합니다.
- 이 과정을 통해 고객의 **변화하는 요구사항을 탄력적으로 처리**할 수 있는 기회를 제공하며, 이를 통해 **변화에 반응하는 것이 계획을 따르는 것보다 우선**한다는 애자일 선언을 실천합니다.

--

### 요구사항 변경의 관리
- 이터레이션이 시작되면 **요구사항 변경은 받아들이지 않**습니다. 이는 애자일 개발이 유연한 계획과 협력적 개발을 추구하지만, 한 번 시작된 개발 주기 내에서는 변경을 최소화하는 원칙을 따릅니다.

--

### 사람과 상호 의사 교환의 중요성
- **첫 번째 가치**로 등장하는 ‘**사람 및 상호 의사 교환이 프로세스나 도구보다 우선**한다’는 원칙은 프로그래밍을 **본질적으로 사람의 활동**으로 바라보는 시각을 제공합니다.
- **XP(Extreme Programming)**는 과도한 작업을 피하고 **지속적인 개발**을 위해 개발자의 과도한 작업이 **역효과**를 낳을 수 있음을 인식하고 있습니다.

--

### 개발자의 생산성과 교육의 중요성
- 연구에 따르면 **개인에 따라 생산성의 차이가 많게는 10배까지 차이가 난다고** 밝혀졌습니다. 이는 단순히 뛰어난 능력을 가진 프로그래머를 고용하는 것이 아니라, **지속적인 교육**과 **개발자의 멘토링**에 더 많은 가치를 두어야 한다는 의미입니다.
- XP는 **짝 프로그래밍(Pair Programming)**을 통해 **개발자 간의 지식 전달 및 공유**를 촉진하고, 이를 통해 팀의 전체 생산성을 높이고 있습니다.

--

애자일 개발 모델은 **빠른 피드백**, **유연한 요구사항 반영**, 그리고 **개발자 간의 협력**을 통해 효율적이고 지속적인 소프트웨어 개발을 추구합니다.


--

### 심화 노트: 짝 프로그래밍 (Pair Programming) - XP의 실현 방안

### 짝 프로그래밍의 기본 개념
- **짝 프로그래밍**은 **XP(Extreme Programming)**의 중요한 실현 방안 중 하나로, **두 명의 개발자**가 하나의 작업을 함께 수행하는 방식입니다.
- 두 개발자는 역할을 분담합니다: 한 명은 **코드를 작성**하고, 다른 한 명은 **코드를 검토**하거나 **다른 작업**을 수행합니다.
- 겉보기에는 두 명이 하나의 일을 하므로 **업무 효율이 떨어지거나 인력 낭비**처럼 보일 수 있습니다. 그러나 실제로는 여러 **장점**이 있습니다.

--

### 짝 프로그래밍의 이점

1. **시너지 효과**
   - 두 명이 한 작업에 집중하므로 **아이디어**와 **경험**이 두 배가 됩니다. 
   - 두 명의 **머리**로 문제를 해결하므로 **효율성**과 **창의성**이 극대화됩니다.

2. **사소한 실수의 빠른 발견**
   - **코딩 중 발생하는 사소한 실수**는 **뒤에서 지켜보는 사람이 즉시 발견**하여 수정할 수 있습니다. 이를 통해 **컴파일 시 발생할 수 있는 문법 오류**를 빠르게 줄일 수 있습니다.

3. **팀에서의 코드 공유 효율성**
   - 짝 프로그래밍을 통해 **코드의 품질**이 향상되면, 나중에 다른 팀원이 **코드를 이해**하려고 할 때 소모되는 시간을 줄일 수 있습니다.

4. **집중력 향상**
   - 혼자 작업하면 **산만해질** 수 있지만, 짝 프로그래밍에서는 **뒤에서 지켜보는 사람이** 있기 때문에 **집중력**이 자연스럽게 높아집니다.

--

### 결론
짝 프로그래밍은 처음에는 비효율적일 수 있지만, **아이디어 공유**, **실수 방지**, **코드 품질 향상** 등 여러 면에서 **장점**이 많습니다. **두 명이 협력**하여 작업을 진행하는 방식은, 결국 **팀 전체의 효율성**을 높이는 결과를 가져옵니다.

--

### 테스트 주도 개발 (TDD) - XP의 중요한 개념

### TDD의 개념
- **테스트 주도 개발 (TDD)**는 **테스트 케이스를 먼저 작성**하고, 그 후에 **테스트를 통과하는 코드**를 작성하는 개발 방식입니다.
- 이 방식은 **결함의 발생 가능성**을 크게 줄일 수 있습니다. 테스트되지 않은 코드가 없기 때문입니다.

--

### TDD의 장점
1. **결함 발생 가능성 감소**
   - 테스트 주도 개발을 통해 작성된 코드는 **테스트되지 않는 코드**가 없어 **결함 발생**을 줄일 수 있습니다.

2. **테스트 용이성 높은 코드 설계**
   - 테스트를 먼저 고려해서 코드를 작성하면, **테스트 용이성**이 높고 **변경 요구**에 유연하게 대응할 수 있는 **설계**가 가능합니다.

3. **요구 사항을 분명하게 드러냄**
   - 테스트 케이스는 **사용자 요구 사항**을 **명확하게 드러내는 효과**를 가지고 있습니다. 이로 인해 코드를 작성하는 개발자는 요구 사항을 명확히 인지한 상태에서 작업할 수 있습니다.

--
그림 6.6  TDD 프로세스
![그림 6.6  TDD 프로세스](csts/images/csts_6.6.png)
--

### TDD의 작업 흐름 (그림 6.6 참조)
1. **테스트 케이스 작성**  
   - TDD의 첫 단계는 **테스트 케이스를 작성**하는 것입니다. 이 테스트는 처음에 실패합니다. 이유는 테스트할 대상 코드가 아직 작성되지 않았기 때문입니다.

2. **테스트를 통과하는 코드 작성**  
   - 테스트가 실패하면, **테스트를 통과**할 수 있도록 코드를 작성합니다. 

3. **리팩토링(Refactoring)**  
   - 코드가 작성된 후에는 필요에 따라 **리팩토링**을 수행합니다. 리팩토링은 **기능 변경 없이 코드의 내부 구조**를 개선하는 작업입니다.
   - 리팩토링을 통해 **중복된 코드**나 **복잡한 로직**을 제거하여 코드의 **단순화**를 꾀할 수 있습니다.

4. **반복 과정**  
   - 이러한 과정을 반복하여 모든 항목을 구현할 때까지 계속 진행됩니다.

--

### "동작하는 깨끗한 코드" (Ron Jeffries)
- **론 제프리스(Ron Jeffries)**는 TDD를 수행하면 **코드가 단순해지고** 이러한 코드를 **“동작하는 깨끗한 코드”**라고 불렀습니다.
  - **동작한다**는 것은 테스트를 통과하는 코드라는 의미입니다.
  - **깨끗하다**는 것은 **리팩토링**을 통해 **중복된 코드가 없**고, **단순화된 코드**라는 의미입니다.

--
심화 노트 : TDD

TDD에 대한 이해를 돕기 위해 아래에 나오는 간단한 예시로 설명하려고 한다(물론 TDD를 지원하는 테스트 프레임워크로 JUnit과 같은 도구를 사용할 수 있지만, 여기에서는 개념적 설명을 위해 이러 한 도구에 관한 설명은 생략한다).
기본적으로 TDD는 단위 테스트를 위한 것이다. 객체 지향 프로그램에서 단위는 보통 하나의 클래스 를 의미한다. 예를 들어, 일련의 정숫값들을 더하는 클래스를 구현한다고 가정하자. 이를 위해 다음 과 같은 (JUnit)테스트 케이스를 작성하였다(TDD는 코드를 구현하기 전에 테스트 케이스를 작성한 다는 사실을 명심하라).

```java
@Test
void testAdd() {
           SumInt s=new SumInt(); //SumInt는 개발할 클래스이다.
}
```

현재 작성되어 있는 코드가 없기 때문에 이 테스트 케이스를 실행하면 컴파일되지 않는다. 우선 컴 파일만 될 수 있게 최소한의 코드만 작성해보자. 컴파일 오류를 피하기 위해서는 SumInt 클래스를 정의해야 한다.

```java
class SumInt {
}
```

테스트가 통과되었으므로 실패하는 테스트를 추가하자.

```java
@Test
void testAdd() {
           SumInt s = new SumInt(); // SumInt는 개발할 클래스이다.
           int r = s.add(10, 20);
}
```

실제 다시 한번 테스트를 실행시켜보면 add 함수가 선언되어 있지 않아 컴파일 오류가 발생한다. 테 스트를 통과하기 위해서는 SumInt 클래스에 add 함수를 정의하여야 한다.

```java
class SumInt {
public int add(int x, int y) { return 0;} // 0은 기본 반환값
}
```

컴파일 오류는 더는 발생하지 않기 때문에 실패하도록 테스트 코드를 추가하자.

```java
@Test
void testAdd() {
           SumInt s = new SumInt(); //SumInt는 개발할 클래스이다.
           int r = s.add(10, 20);
           assertEquals(30, r);
}
```

테스트를 수행하면 단정문 “assertEquals(30, r)”을 통과하지 못함을 알 수 있다. 단정문을 통과하 기 위한 코드를 다음과 같이 작성해보자.

```java
class SumInt {
public int add(int x, int y) { return x+y; } 
}
```
다시 테스트를 실행하면 이제 더는 오류가 검출되지 않을 것이다.

--
### 지속적 통합(Continuous Integration, CI)

지속적 통합(Continuous Integration, CI)은 **TDD**와 더불어 애자일 개발에서 중요한 실천 규칙 중 하나입니다. 말 그대로, 지속적 통합은 **통합이 어느 한 시점에 이루어지는 것이 아니라 지속적으로 통합을 수행**하는 것을 의미합니다. 그렇다면 얼마나 자주 통합이 이루어져야 '지속적'일까요? 지속적 통합에서는 각 개발자가 작업한 코드의 업데이트를 **코드 저장소에 반영할 때마다** 통합이 이루어집니다. 이는 하루에도 몇 번씩 통합될 수 있다는 의미입니다.

### 지속적 통합의 개념
지속적 통합의 개념에는 코드 통합 작업뿐만 아니라 **코드 품질을 평가하는 테스트**와 같은 여러 품질 관리 활동들이 포함됩니다. 지속적 통합은 통합이 빈번하게 이루어질 뿐만 아니라, 통합이 완료된 후 즉시 잠재적인 문제가 있는지 결과를 바로 알 수 있기 때문에 **소프트웨어 품질을 높이고 통합의 위험을 줄이는 대표적인 방법**입니다. 또한, 지속적으로 품질을 관리하는 방법으로 볼 수 있습니다.

--
### 지속적 통합의 이점
1. **통합 지연에 따른 비용 증가 방지**  
   지속적 통합은 통합을 자주 하여 **지연으로 인한 비용 증가**를 방지할 수 있습니다.

2. **빠른 결함 발견으로 비용 감소**  
   결함을 빠르게 발견하고 수정함으로써 **결함이 늦게 발견될수록 증가하는 비용**을 감소시킬 수 있습니다.

3. **항상 빌드 가능한 소프트웨어 버전 유지**  
   지속적 통합을 통해 **항상 빌드 가능한 소프트웨어 버전**을 유지할 수 있으며, 이는 **소프트웨어 품질에 대한 확신**을 제공합니다.

### 결론
지속적 통합(CI)은 개발 프로세스에서 코드 품질을 높이고, 통합 과정에서 발생할 수 있는 리스크를 최소화하는 중요한 기법입니다. 이를 통해 **빠른 결함 발견, 비용 절감, 그리고 품질 확신**을 얻을 수 있으며, 결과적으로 더 효율적이고 안정적인 소프트웨어 개발을 지원합니다.


--
Exercise

--

01   다음은 테스트 주도 개발(Test-Driven Development, TDD) 프로세스를 나타내는 그림이다. (가)에 들어갈 용어는 무엇인가?

![c6.ex01](csts/images/csts_6.ex01.png)

① 재구성(Restructuring)
② 리팩토링(Refactoring)
③ 재공학(Reengineering)
④ 역공학(Reverse engineering)

해설:

![c6.ex01-1](csts/images/csts_6.ex01-1.png)

--
02 리팩토링을 수행한 후에 수행하는 테스트는?
① 리그레션 테스트(Regression test)
② 재테스트(Retest)
③ 인수 테스트((Acceptance test)
④ 벤치마크 테스트(Benchmark test)

해설 :
코드의 내부구조를 개선하는 리팩토링 작업을 수행한 뒤에는 이 작업으로 인해 기존의 기능에 새로운 결함이 도입되었는지 검증해야 하므로 리그레션 테스트를 수행한다.

--

03 소프트웨어 생명 주기 모델인 순차적 모델과 테스트에 관한 설명 중 올바른 것은 무엇인가?
① 폭포수 모델은 개발 완료 후 발견된 결함의 수정 비용과 시간이 적게 소요된다.
② V-모델에서 테스트 활동은 개발이 종료됨과 동시에 시작된다.
③ V-모델에서 개발 산출물에 대한 동적 테스트가 수행된다.
④ 폭포수 모델은 테스트를 하나의 개발 단계로만 간주한다.

해설:
① 폭포수 모델은 개발이 거의 완료될 무렵에 결함을 발견하여 수정할 때 비용과 시간이 훨씬 많이 든다.
② V-모델에서 테스트 활동은 개발이 시작됨과 동시에 시작된다.
③ V-모델에서 개발 산출물에 대한 정적 테스트가 수행된다.
④ 폭포수 모델은 기본적으로 테스트 작업을 코딩 단계 후의 한 단계로만 취급한다.

--

04   다음에서 설명하는 용어는 무엇인가?

∙ 개발자 관점의 검증(Verification)과 사용자 관점의 확인(Validation)을 기반으로 한 개발 모델
∙ 소프트웨어 개발방법론 중 폭포수 개발모델(Waterfall)에 근간을 두고 있는 모델
∙ 소프트웨어 개발 단계별 테스트 유형이 대응하여 정의됨
(요구사항↔인수 테스트, 요구사항 분석↔시스템 테스트, 구조설계↔통합 테스트, 상세설 계 ↔단위 테스트)

--
정답   02 ①  03 ④  04 V&V모델, 브이모델

--

05   아래의 V-모델에서 빈칸에 들어갈 알맞은 용어를 적절하게 나열한 것은 무엇인가?


![c6.ex05](csts/images/csts_6.ex05.png)

① (가) 단위 테스트, (나) 시스템 테스트, (다) 통합 테스트, (라) SDLC
② (가) 단위 테스트, (나) 통합 테스트 (라) 시스템 테스트, (라) SDLC
③ (가) SDLC, (나) 단위 테스트, (다) 통합 테스트, (라) 시스템 테스트
④ (가) SDLC, (나) 단위 테스트, (다) 디버깅, (라) 시스템 테스트

해설:

![c6.ex05](csts/images/csts_6.ex05-1.png)
--

06 다음 중 애자일 선언(Agile Manifesto)과 가장 거리가 먼 것은?
① 사람 및 상호 의사 교환이 프로세스나 도구보다 우선한다.
② 동작하는 소프트웨어가 포괄적인 문서보다 우선한다.
③ 고객과의 계약이 무엇보다 우선한다.
④ 변화에 반응하는 것이 계획을 따르는 것보다 우선한다.

해설:
① 사람 및 상호 의사 교환이 프로세스나 도구보다 우선한다.
② 동작하는 소프트웨어가 포괄하는 문서보다 우선한다.
③ 고객과의 협력이 계약 협상보다 우선한다.
④ 변화에 반응하는 것이 계획을 따르는 것보다 우선한다.

--

정답   05 ③  06 ③

--

07   테스트 주도 개발(Test-Driven Development)인 TDD는 테스트 되는 실제 프로그램의 코 드를 먼저 작성하고 프로그램에 대한 테스트 케이스를 나중에 작성하는 방식이다.
[○/×]

해설 :
테스트 주도 개발(Test-Driven Development)인 TDD는 프로그램에 대한 테스트 케이스를 먼저 작성 하고, 이 테스트 케이스로 테스트 되는 실제 프로그램의 코드를 나중에 작성하는 방식이다.

--
08 다음 소프트웨어 생명 주기 모형 중 진화적 개발 모델에 대한 설명으로 가장 올바른 것은?
① 요구사항이 프로젝트 시작부터 명확하게 정의된 프로젝트에 적합한 개발 모델이다.
② 시스템의 모든 구성 요소를 한꺼번에 개발 완료하는 방식이다.
③ 폭포수 모델보다 프로젝트 관리가 용이하여 보다 큰 차세대 프로젝트에 적합한 개발 모델 이다.
④ 사이클마다 리스크 분석이 수행되므로 발생하는 문제점을 해결할 방안을 마련할 수 있다.

해설 :

④ 요구사항이 불명확할 때 사용하기 적합한 개발 모델로 시스템 구성 요소를 조금씩 개발 반복적으로 수행하여 프로젝트를 진행하는 방식으로 대규모 프로젝트에 적합하다. 매 단계 테스트가 수행되므로 많은 문제점을 해결할 기회를 가질 수 있다.

--

09   폭포수 모델과 같은 순차적 개발 모델은 매 단계에서 적정한 테스트가 이루어지므로 고객 의 주요 요구사항에 대해 우선 프로토타입을 개발하고 사용자 평가 및 테스트를 거쳐 다음 개발 주기를 시작한다.[○/×]

해설:
진화적 개발 모델에 대한 설명이다. 
진화적 개발 모델은 이터레이션(Iteration)과 점진적(Incremental) 개발 원칙에 바탕을 두고 있다. 이 개발 모델은 시스템의 구성요소 중 핵심 부분을 개발한 후, 각 구성요소와 추가 요구사항을 여러 이터레 이션을 통해 개선 발전 시켜 최종 완성품을 개발한다. 
나선형 모델의 일반적인 방법은 기술적으로 어렵거나 고객의 비즈니스 가치를 최상으로 만드는 요구사 항들에 대해 우선 프로토타입을 개발하고, 프로토타입에 대한 테스트 및 사용자의 평가를 거쳐 다음 개 발 주기를 시작한다.

--
10   소프트웨어 생명 주기 모델 중 애자일(Agile) 개발 모델은 프로세스와 문서 위주의 방법론 으로 요구사항의 변경이 빈번하게 발생하는 경우에 적합한 방법이다.[○/×]

해설:
프로세스와 문서 위주의 방법론은 순차적 개발모델이다. 

--
정답   07 ×  08 ④  09 ×  10 ×
