# 제 7 장 테스트 자동화

## 7.1 개 요

테스트 자동화란 도구를 사용하여 테스트 프로세스의 일부 혹은 전부를 자동화하는 것을 의미한다. 사람이 수행하는 단순하고 반복적인 일에 도구를 사용하여 효율적으로 작업을 수행할 수 있게 하고, 테스터의 부담을 줄여 좀 더 창의적인 작업에 집중할 수 있게 한다.


## 도구 분류

표 7.1은 테스트를 지원하는 업무에 따라 도구를 분류한 것이다.

![표 7.1 도구 분류](csts/images/csts_table_7.1.png)

--

## 수작업 테스트의 문제

현재 개발 중인 웹 사이트의 로그인 기능이 올바르게 동작하는지 테스트하기 위해 그림 7.1의 단계들을 수행해야 하는 상황을 가정해보자.

## 수작업 테스트의 어려움

만약 이 단계들을 수작업으로 수행해야 한다면 굉장히 단순한 작업인데도 수작업으로 많은 실수가 발생할 가능성이 있다.

웹 사이트 주소나 아이디, 또는 비밀번호를 잘못 입력할 수 있고, 주어진 절차를 빠뜨리거나 따르지 않으면 올바른 테스트를 수행할 수 없게 된다.

## 실수 방지

또한, 로그인 기능이 올바르게 동작하는지 확인하기 위해 웰컴 페이지를 사람이 직접 확인해야 한다.



1. 웹 사이트 주소 입력
2. ld 필드에 가입한 아이디 입력
3. 패스워드 필드에 비번 입력
4. 로그인 버튼 클릭
5. 웰컴(welcome) 페이지 확인
그림 7.1 로그인 검증을 위한 테스트 단계

--

그림 7.2는 그림 7.1을 셀레늄(Selenium)의 JUnit Webdriver 코드로 변환한 것이다. 셀
레늄은 웹 애플리케이션 테스트를 위한 프레임워크이며 Java, C#, PHP, Ruby 등 많은 언
어를 지원한다. IE, Chrome, Firefox 등 대부분의 브라우저 및 윈도우와 리눅스 등 많은
플랫폼에서 실행이 가능하다.

```java
@Test
public void shouldVisitWelcomePage() throws IOException {
driver.get(“웹 사이트 주소”);
driver.findElement(By.id(“id”)).sendKeys(“아이디 ”);
driver.findElement(By.id(“pwd”)).sendKeys(“비번 ”);
driver.findElement(By.id(“btnsignIn”)).click();
assertEquals(“웰컴 메시지”,driver”.findElement(By.xpath(“blah blah”)).getText())
}
```

그림 7.2 JUnit Webdriver 코드 변환

## 자동화된 테스트의 장점

이와 같이 도구를 사용하여 실행할 수 있도록 자동화하면  
테스터는 단순하면서 반복적인 업무에서 벗어나 일관성을 유지하면서  
빠르게 테스트를 수행할 수 있다.

--

## 성능, 부하, 스트레스 테스트

성능 테스트, 부하 테스트, 스트레스 테스트 등과 같이  
실제 자동화하지 않으면 효과적인 테스트를 할 수 없는 분야가 있다.  
예를 들어, 부하 테스트나 스트레스 테스트를 위해 100명의 사용자가  
동시에 시스템에 접근해야 하는 경우에 100명의 사용자를 실제 고용해서  
테스트를 수행한다면 시간과 비용이 너무 많이 들 것이다.

--

## 자동화의 효과

반면에 주어진 테스트 스크립트를 100개의 쓰레드나 프로세스를 이용하여  
자동으로 수행한다면 훨씬 효과적으로 테스트를 수행할 수 있다.

--

## 자동화와 수동 테스트의 균형

물론, 모든 경우에 테스트 작업을 자동화하는 것이 정답은 아니다.  
예를 들어, 자주 반복적으로 수행되는 테스트가 아니고 한두 번 수행되는 경우에는  
굳이 테스트를 자동화할 필요가 없을 것이다.

--

## 매뉴얼 테스트의 필요성

경우에 따라서는 자동화된 테스트보다 매뉴얼 테스트(Manual test)가  
효과적일 때도 있다. 예를 들면, 사용자 인터페이스 테스트를 수행할 때  
화면 배경 색상과 버튼 배경 색상이 동일하여 버튼을 구분하기 어렵거나  
화면 전환이 부자연스러운 경우는 사람이 화면을 지켜보고 있을 때 쉽게 발견할 수 있다.


--
## 7.2 테스트 자동화 분야 및 테스트 도구

전통적인 테스트 자동화에서는 테스트 케이스의 실행을 자동으로 하는 자동화를 핵심 요소로 간주하기 쉬운데,  
완성도 높은 자동화 인프라는 테스트의 여러 단계에 걸쳐 전체적인 테스트 활동의 전문성과 안정성에 관여한다.  
이런 자동화 모델의 예로 키스 스토비(Keith Stobie)와 마크 버그먼(Mark Bergman)의 SEARCH 모델이 있다.

--

## SEARCH 모델

SEARCH 모델에서 테스트 자동화는  
셋업(Set up), 실행(Execution), 분석(Analysis), 보고(Report), 정리(Clean up), 도움말(Help)  
의 총 6단계로 구성된다. 각 단계를 자동화함으로써 효율을 높이고 사람의 실수(Human error)를 예방할 수 있으며,  
전문성과 일관성을 가진 테스트를 할 수 있다.

--

## ISO/IEC/IEEE 29119

ISO/IEC/IEEE 29119는 테스트 프로세스를  
조직 테스트 프로세스, 테스트 관리 프로세스 및 동적 테스트 프로세스로 분류하였으며,  
이들 테스트 프로세스에 관련된 활동들은 모두 자동화 대상이 될 수 있다.  

--

## 동적 테스트 프로세스

이번 절에서는 ISO/IEC/IEEE 29119의 동적 테스트 프로세스 활동을 지원하는 도구에 대해 살펴본다.

![그림 7.3 ISO/IEC/IEEE 29119 동적 테스트 프로세스](csts/images/csts_7.3.png)


--

## 테스트 설계 도구의 기대 결과 생성

테스트 설계 도구는 기대 결과도 생성한다. 예를 들어, **EvoSuite**는 유전자 알고리즘(GA, Genetic Algorithm)에 바탕을 두고 소스 코드를 분석하여 테스트 케이스를 생성한다.

--

## EvoSuite의 기대 결과 생성 방식

EvoSuite는 기대 결과를 생성하기 위해 명세 정보를 활용하지 않고,  
실제 프로그램을 실행하여 실행 결과를 기대 결과로 대신하는 방식을 취한다.

--

## 레거시 시스템에서의 활용

이러한 도구는 레거시 시스템을 기반으로 프로젝트를 진행할 때 생성된 테스트 케이스들을 리그레션 테스트 케이스로 활용할 수 있다.  

예를 들어, 레거시 시스템에 새로운 기능을 추가하기 위해 시스템을 변경할 때,  
기존의 기능이 영향을 받았는지 테스트하기 위해 실행 결과를 기대 결과로 대신하는 테스트 케이스들을 실행할 수 있다.

--

## 7.2.2 테스트 환경 구축 도구

테스트 환경 구축은 테스트를 원활하게 수행하기 위한 가장 기본적이면서 중요한 작업이다.  
개발자 환경에서 작동이 되는 애플리케이션이 실제 테스트 환경이나 운영 환경에서는 작동하지 않는 경우가 있다.  
이렇게 일관성 없이 애플리케이션이 실행되는 이유는 매우 다양하다.  
운영 및 테스트 환경 설정이 개발 환경과 다르거나 사용하는 라이브러리 버전이 다를 수도 있다.  
그뿐만 아니라 애플리케이션 환경을 설정하는 작업은 대부분 매우 까다롭기 때문에 환경을 구축하는 동안 실수를 하거나  
구성 단계를 누락하기도 하고 순서를 지키지 않을 수도 있다.

--

## IaC (Infrastructure as Code)

최근에 **IaC (Infrastructure as Code)** 개념이 등장하였다.  
IaC는 말 그대로 “인프라를 코드화한다”, “인프라를 코드로 기록한다”의 의미이다.  
즉, IaC를 통해 시스템 환경을 수동으로 구성하는 대신 시스템 환경 구성 정보를 기록한 스크립트를 사용하여 자동으로 인프라를 구성한다.  
이와 같이 인프라 구성 정보를 코드로 관리해두면 애플리케이션 개발 시 Git 등과 같은 버전 관리 도구로 소스 코드를 관리하는 것처럼  
변경 이력을 일원화하여 관리할 수 있다.

--

## 도커 (Docker)

**IaC** 개념을 바탕으로 한 **도커(Docker)** 는 애플리케이션 실행 환경을 자동으로 설치할 수 있는 도구이다.  
도커는 소프트웨어 컨테이너(Container)라는 단위로 패키징하며, 이 컨테이너에는 라이브러리, 미들웨어, 시스템 도구, 런타임 환경 등  
애플리케이션을 실행하는 데 필요한 모든 것을 포함할 수 있다.  
이러한 애플리케이션 실행 환경을 도커에서는 “Dockerfile”이라는 소스 코드로 환경 구성 정보를 기록하여 관리한다.  

--

## 도커의 장점

따라서 애플리케이션을 신속하게 배포 및 확장할 수 있으며, 코드가 문제없이 개발자 플랫폼에 구애받지 않고 실행될 것임을 확신할 수 있다.  
즉, 누구라도 구성파일 실행을 통해 테스트 환경이나 운영 환경을 아주 손쉽게 구축할 수 있다.


--

## 7.2.3 테스트 실행 도구

테스트 실행은 가장 전통적인 테스트 자동화의 핵심 분야이다.  
테스트 실행 도구는 테스트 케이스를 자동으로 실행할 수 있도록 스크립트로 변환하여 실행한다.  
테스트 케이스를 컴퓨터가 실행할 수 있는 스크립트로 변환하는 방법 중에서 대표적인 것이 **Record&Playback** 방식이다.  
이 방식을 지원하는 도구는 사용자가 브라우저 등을 통해 시스템을 사용하는 행위와 시스템 반응을 스크립트로 기록하고 이를 다시 반복 실행할 수 있도록 한다.  
따라서 도구 사용자가 테스트 스크립트 언어에 관한 특별한 지식이 없어도 테스트 케이스를 설계하여 실행할 수 있다.

--

## Katalon Studio

**Katalon Studio**는 **Record&Playback** 기능을 제공하는 도구이다.  
Katalon Studio는 크롬 브라우저의 플러그인으로 제공되며 기존의 **Selenium IDE**의 기능을 제공한다.  
그림 7.4는 사용자가 **네이버**에서 **한성대학교 홈페이지**를 찾아가는 과정을 보여준다.

![그림 7.4 사용자의 행위를 기록](csts/images/csts_7.4.png)


Katalon
Studio는 이러한 사용자의 행위를 그림 7.5와 같은 스크립트로 저장하고 사용자의 관여 없
이 다시 실행할 수 있다. 이렇게 번역된 스크립트는 Selenium 프레임워크에서 사용할 수
있도록 Java, C#, Python 등으로 변환될 수 있으며 심지어 Robot 프레임워크에서 사용할
수 있도록 변환 기능을 제공한다.

--

![그림 7.5 Katalon 스크립트](csts/images/csts_7.5.png)

## 테스트 실행 프레임워크 분류

테스트 실행 프레임워크는 스크립팅 언어 수준에 따라 다음과 같이 분류할 수 있다:

--

### 선형(Linear) 프레임워크
- 스크립트를 작성하는 가장 간단한 형태이다.
- 모듈과 같은 스크립트를 구조화하는 수단을 제공하지 않으며, 스크립트의 테스트 단계들을 순차적으로 실행한다.
- **Record&Playback**을 지원하는 도구에서 주로 사용된다.

--

### 모듈 기반(Modular Based) 프레임워크
- 스크립트를 모듈화할 수 있는 여러 수단을 제공한다.
- 특히, 모듈 호출 기능은 한 스크립트에서 다른 스크립트를 호출할 수 있다.
- 하나의 큰 스크립트를 여러 개의 작은 스크립트로 분할하여 관리할 수 있으며, 여러 스크립트에서 공통적으로 필요하는 스크립트를 개발하는 비용을 줄일 수 있다.

--

### 데이터 주도(Data-Driven) 프레임워크
- 테스트에 사용되는 데이터를 테스트 스크립트의 로직과 분리하여 보관한다.
- 어플리케이션의 같은 기능을 다양한 입력 데이터로 여러 번 테스트할 때 유용하다.
- 테스트 데이터 셋을 스크립트 로직 내에 하드코딩하지 않고 엑셀, 텍스트 파일, CSV 파일 등에 보관하여 입력 데이터를 전달함으로써 테스트 효율을 높일 수 있다.
- 여러 입력 데이터로 반복 테스트할 수 있으며, 테스트 스크립트와 데이터는 독립적이어서 각각 변경이 가능하다.

--

### 키워드 주도(Keyword-Driven) 프레임워크
- 테스트 케이스와 애플리케이션 간의 결합을 줄여 애플리케이션이 변경되더라도 테스트 케이스에 영향을 미치지 않도록 한다.
- **키워드**란 어플리케이션을 테스트할 때 요구되는 다양한 액션이나 단계를 캡슐화하는 빌딩 블록이다.
- 입력 필드의 위치 변경과 같은 애플리케이션 변경에도 테스트 케이스를 수정할 필요 없이 키워드를 수정하여 대응할 수 있다.

--

### 키워드 주도 테스트 예시

예를 들어, 고객 정보를 애플리케이션에 추가하기 위해서는 다음과 같은 여러 단계가 필요하다:

- 고객 이름 입력
- 고객 주소 입력
- 전화번호 입력
- 등록 버튼 클릭
- 올바르게 추가되었는지 확인
--

이러한 단계들은 구체적으로 입력 필드를 확인하고 필요한 정보를 전달하는 등의 여러 기술적인 로직을 포함한다. 하지만 키워드 주도 테스트에서는 이러한 기술적인 단계를 모두 캡슐화하여 하나의 키워드, 예를 들어 “ADD A NEW CUSTOMER”로 정의한다.

테스트 설계자는 미리 정의된 키워드를 조합하여 테스트 케이스를 작성할 수 있다. 따라서 애플리케이션이 변경되어도, 테스트 케이스는 키워드를 기반으로 작성되었기 때문에 애플리케이션의 변경에 영향을 받지 않으며, 수정이 필요하지 않다.

--

### 표 7.2: 테스트 프레임워크

![표 7.2 테스트 프레임워크](csts/images/csts_table_7.2.png)


--

### 7.2.4 이슈 관리 도구

이슈 관리 도구는 과거에는 버그 추적 도구로 불렸습니다. '이슈'는 일반적으로 사건 또는 문제점을 의미하며, 원래는 버그만을 다루는 도구였으나, 현재는 프로젝트 전반에 걸친 다양한 문제들을 관리하는 도구로 확장되었습니다. 

이슈에 해당하는 예시는 다음과 같습니다:
- 신규 고객 요구사항
- 기능 개선
- 버그 수정
- 문서 작업
- 시스템 설치 작업

따라서 이슈 관리 도구는 단순히 버그 추적에 그치지 않고 프로젝트 관리 도구로도 활용됩니다. 이 절에서는 테스트를 통해 발견된 문제점, 즉 이슈에 한정해서 설명하겠습니다.
--

### 이슈 관리의 중요성

테스트를 통해 검출된 문제점은 시스템 품질을 저하시킬 수 있으며, 사용자 불만족을 유발할 수 있습니다. 따라서 식별된 문제점은 가능한 빨리 해결되어야 합니다. 만약 문제가 간단한 결함이라면 개발자가 즉시 소스 코드를 수정하고 시스템을 재빌드하여 해결할 수 있습니다.

그러나 일반적으로 테스트에서 발견된 결함은 재연이 어렵거나 그 근본 원인을 파악하기 어려운 경우가 많습니다. 이런 경우에는 해결까지 시간이 소요될 수 있으며, 중요한 결함은 반드시 해결되었는지 확인하고 관리해야 합니다. 또한 결함을 검출한 테스터와 이를 해결할 개발자 간에 결함 정보를 공유하는 것이 중요합니다.
--

### 결함 해결 과정

개발자가 결함을 수정했다고 생각하더라도, 결함이 완전히 제거되지 않았거나 수정 과정에서 새로운 결함이 발생했을 수 있습니다. 따라서 수정된 소스 코드를 다시 테스트하여 결함이 확실히 제거되었는지 확인해야 합니다.


### 결함 생명 주기 (Defect Life Cycle)

결함이 식별되면 그 결함은 완전히 해결될 때까지 추적되고 관리되어야 합니다. 대부분의 이슈 관리 시스템은 결함이 식별된 시점부터 완료될 때까지의 상태를 추적하는 기능을 제공합니다. 이러한 결함의 상태 변화 과정을 **결함 생명 주기**라고 하며, 프로젝트 특성에 맞게 조정할 수 있습니다. 예를 들어, 아래와 같은 결함 생명 주기를 따릅니다.

![그림 7.6 결함 생명 주기 예](csts/images/csts_7.6.png)

--

#### 결함 상태

1. **신규 상태 (New)**  
   - 테스터는 테스트를 수행하여 결함을 식별합니다. 
   - 결함에 대한 정보는 기록되고 보고됩니다. 
   - 결함이 "신규" 상태로 정의되며, 분석이 시작됩니다.
   - 해결이 불필요한 결함은 "완료" 상태로 변경될 수 있습니다. 예를 들어, 사소한 결함이나 이미 해결된 결함은 바로 "완료"로 처리됩니다.
   - 해결해야 할 결함은 개발자에게 수정이 지시되며, 상태는 "진행"으로 변경됩니다.

2. **진행 상태 (In Progress)**  
   - 개발자는 결함을 해결하기 위해 소스 코드를 수정합니다.
   - 결함 수정이 완료되면 개발자는 테스터에게 재테스트를 요청합니다.
   - 상태는 "해결"로 변경됩니다.
--

3. **해결 상태 (Resolved)**  
   - 테스터는 개발자가 보고한 수정 사항을 검증합니다. 
   - 동일한 테스트 케이스를 사용하여 결함이 해결되었는지 확인합니다.
   - 결함이 해결되고 새로운 결함이 발견되지 않으면 상태를 "완료"로 변경합니다.
   - 만약 기존 결함이 여전히 발견되거나 새로운 결함이 발생하면, 개발자에게 다시 수정이 지시되며 상태는 "진행"으로 변경됩니다.

4. **완료 상태 (Closed)**  
   - 테스터가 결함이 해결되었음을 재테스트를 통해 확인한 상태입니다. 
   - 결함이 "완료" 상태에 도달하면 최종적으로 검출된 결함을 종결시킵니다.
   - 매우 사소한 결함은 테스트 관리자가 바로 "완료" 상태로 변경할 수도 있습니다.


### 결함 생명 주기의 복잡성

실제로 결함 생명 주기는 위에서 설명한 것보다 복잡할 수 있습니다. 예를 들어, 테스터가 결함 해결을 확인한 후 테스트 관리자가 재차 확인하는 절차가 추가될 수 있습니다. 또한, 개발자가 결함을 해결하려 했으나 결함이 재연되지 않는 경우, 테스터에게 결함의 구체적인 상황을 재요청하는 경우도 있을 수 있습니다.
--

### 이슈 관리 도구

현재 다양한 이슈 관리 도구들이 시장에 출시되어 있습니다. 이 도구들은 결함 추적을 비롯하여 프로젝트 관리, 업무 흐름, 규칙 등을 지원하는 중요한 역할을 합니다. 이슈 관리 시스템을 도입할 때는 신중을 기해야 합니다. 

한 번 도입한 시스템은 다른 제품으로 변경하기 어려운 경우가 많으며, 변경 시 데이터 이관 등의 과정에서 시간과 비용이 많이 들 수 있습니다. 또한, 이슈 관리 도구는 업무 규칙과 밀접하게 연결되므로 사용성, 비용, 기능, 서비스 제공 형태 등 여러 요소를 고려하여 도구를 선정하는 것이 중요합니다.

#### 대표적인 이슈 관리 도구

![표 7.3 이슈 관리 도구](csts/images/csts_table_7.3.png)


--
### 테스트 도구 선정

자주 반복되는 테스트를 수작업으로 수행하는 것은 많은 비용을 초래합니다. 속도가 느리거나 도구를 사용하면 더 안전하게 작업을 수행할 수 있는 경우, 테스트 자동화가 적합합니다. 반면, 자주 수행되지 않는 테스트를 자동화하는 것은 비용 대비 효과가 낮을 수 있습니다. 또한, 테스트 프로세스의 모든 작업을 100% 자동화하는 것도 올바른 선택이 아닐 수 있습니다.

#### 테스트 자동화의 한계

예를 들어, 요구 사항이 자주 변경되는 경우에는 테스트 케이스도 함께 변경되어야 하며, CAPTCHA, 폰트, 색상 등과 관련된 경우에는 자동화된 테스트보다는 수동 테스트가 더 효과적일 수 있습니다. 따라서 테스트 자동화는 매뉴얼 테스트를 대체하기보다는 상호 보완하는 방향으로 이루어져야 합니다. 테스트 조직과 프로세스 상황에 따라 반자동화 또는 일부 자동화도 고려할 필요가 있습니다.
--

#### UI 테스트 자동화

일반적으로 테스트 자동화에서 먼저 시도하는 부분은 UI 테스트입니다. UI 테스트는 시스템 전체를 테스트 대상으로 하기 때문에 매우 매력적입니다. 그러나 UI 테스트는 수많은 테스트 케이스들이 존재하게 되어 속도가 느려질 수 있습니다. 또한, UI에 대한 요구 사항은 자주 변경되기 때문에 UI가 변경되면 테스트 스크립트도 변경해야 합니다.

#### 거짓 양성

만약 요구 사항이 변경되었는데 테스트 케이스가 제때 수정되지 않으면 거짓 양성(False positive)이 발생할 수 있습니다. 거짓 양성은 실제 결함이 아닌데 결함으로 잘못 판단한 경우를 의미합니다. 프로그램 구현에는 문제가 없지만 프로그램 구현 변경에 따라 수정되지 않은 테스트 케이스들이 잘못된 결함을 보고하게 됩니다. 이로 인해 자동화 효율성이 저하될 수 있습니다.


--
![그림 7.7 테스트 피라미드](csts/images/csts_7.7.png)

### 테스트 피라미드

테스트 자동화 대상과 관련하여 Lisa Crispin의 테스트 피라미드 개념이 널리 알려져 있습니다. **그림 7.7**에서 볼 수 있듯이, 피라미드에서 **UI 테스트**, **통합/API 테스트**, **컴포넌트 테스트**가 차지하는 영역의 넓이가 다릅니다. 각 테스트 타입이 차지하는 영역의 넓이는 **투자 대비 효과(ROI)**와 **자동화해야 하는 양**을 의미합니다. 

--

#### 컴포넌트 테스트의 중요성

컴포넌트 테스트에 자동화가 많이 이루어질수록 투자 대비 효과가 많아진다는 것을 의미합니다. 컴포넌트 테스트 케이스는 통합 테스트나 UI 테스트보다 쉽게 작성할 수 있으며, 테스트 실행에 따른 피드백이 빠릅니다. 또한, 결함이 발견되었을 때 **단위 테스트**는 결함을 발생시키는 부분을 쉽게 식별하여 수정할 수 있지만, **UI**나 **통합 테스트**에서 발견된 결함은 결함을 발생시키는 부분을 찾기 어려워 결함 수정에 시간이 많이 소요됩니다.

#### 테스트 피라미드의 시사점

테스트 피라미드가 시사하는 점은 새로운 테스트 케이스를 개발할 때 **UI**나 **통합 테스트 케이스** 형태로 개발하는 대신 가능한 한 **단위 테스트 케이스**로 개발하라는 것입니다. **단위 테스트**로 테스트하지 못할 때만 **통합 테스트 케이스**를 개발하고, 단위나 통합 테스트로 부족할 때만 **UI 테스트 케이스**를 개발하는 것이 이상적입니다.


--

![그림 7.8 테스트 도구 선정 프로세스](csts/images/csts_7.8.png)

### 테스트 도구 선정 프로세스

테스트 자동화를 위한 올바른 도구를 선정하는 작업은 매우 중요합니다. **그림 7.8**은 테스트 도구를 선정하는 프로세스를 보여주며, 각 단계는 다음과 같은 작업들을 수행합니다.

1. **요구사항 정의**
   - 테스트 도구에 대한 요구사항을 식별하고 정의합니다. 도구를 도입할 때는 조직의 **프로세스**와 **능력**을 고려해야 합니다. 만약 조직의 테스트 프로세스나 능력이 충분히 성숙되지 않았다면 도구 사용에 따른 프로세스 변화에 적절히 대처할 수 없어 효과를 제대로 볼 수 없습니다.

2. **도구 조사**
   - 요구사항을 고려하여 **상업용 도구**나 **오픈소스 소프트웨어** 등을 조사합니다. 또한, **자체 개발** 가능성도 검토합니다.

--

3. **도구 평가**
   - 평가 기준을 마련하고 도구가 요구사항에 얼마나 부합하는지 평가합니다. 이때 도구 공급자의 명성, 사후 관리, 도구 갱신 주기 등 다양한 요소를 고려해야 합니다.

4. **파일럿 프로젝트**
   - 도구의 시험판 버전을 사용하거나 파일럿 프로젝트를 수행하여 도구의 품질을 평가합니다. 이 과정에서 도구의 문제점을 도출하고 해결 방안을 검토합니다.

5. **도구 선정**
   - 도구 도입에 따른 테스트 프로세스의 개선 효과 등을 고려하여 **비용 대비 이득**을 추정하고 최종적으로 도구를 선정합니다.

6. **도구 도입**
   - 실제로 도구를 조직에 도입하는 단계입니다. 도구 도입에 따른 테스트 프로세스를 개선하고, 도구 배포 계획을 수립하며, **교육** 및 **훈련 계획**을 세웁니다.


--
Exercise
--


01 다음 중 정적 분석 도구의 용도로 적합하지 않은 경우는?
① 사이클로매틱 복잡도 계산 ② 코딩 표준 준수 검사
③ 사용하지 않은 변수 검출 ④ 테스트 케이스 커버리지 측정
해설 : ④ 동적 분석 도구

02 다음 중 테스트 관리 도구의 목적이 아닌 것은?
① 테스트 계획, 노력 추정, 테스트 일정과 관련된 작업 수행
② 요구사항과 테스트 케이스 추적성 관리
③ 테스트 진행과 보고
④ 모델이나 소스 코드로부터 테스트 케이스 생성
④ 테스트 설계 도구


03 다음은 테스트 도구를 선정하는 프로세스의 한 단계에 대한 설명이다. ( )에 알맞은 용
어는?
도구의 시험판 버전을 사용하거나 ( )를 수행하여 도구의 품질을 평가한다. 또한 도구의 문
제점을 도출하고 해결방안을 검토한다.

![c7.ex03](csts/images/csts_7.ex03.png)

--
정답 01 ④ 02 ④ 03 파일럿 프로젝트
--

04 테스트 자동화에 대한 설명으로 올바르지 않은 것은?
① 많은 경우 테스트에 소요되는 수행시간을 줄일 수 있다.
② 적은 비용으로 테스트 환경을 구축할 수 있다.
③ 테스트 환경의 다양화로 테스트 커버리지를 확대할 수 있다.
④ 테스트 실행 및 결과 확인 과정에서 사람의 실수를 줄일 수 있다.
해설 : ② 테스트 도구 구매 및 개발 비용, 테스트 스크립트 개발 비용, 테스트 엔지니어 훈련 비용 등 프로젝
트 초반에 테스트 자동화를 위해 상당한 투자 비용이 발생한다.

05 다음 테스트 자동화 프레임워크 필요성에 대한 설명으로 올바르지 않은 것은?
① 테스트 대상 시스템에 대한 의존도 최대화
② 테스트 케이스 중복 최소화
③ 테스트 스위트(Test Suite)의 효율적 구성 및 관리
④ 테스트 수행 및 결과의 저장 및 관리(DB화)

해설 : 테스트 대상 시스템에 대한 의존도 최소화를 해야 한다.

06 다음 중 SEARCH 모델의 테스트 자동화 구성 요소로 올바르지 않은 것은?
① Analysis (분석) ② Execution (실행)
③ Setup (셋업) ④ Retest (재테스트)

해설 :
SEARCH 모델: Setup(셋업) → Execution(실행) → Analysis(분석) → Report(보고) → Cleanup
(정리) → Help(도움말)

--
정답 04 ② 05 ① 06 ④

--

07 테스트 실행 프레임워크를 지원하는 스크립팅 언어 수준에 따라 다음과 같이 분류할 수
있다. 다음 중 프레임워크에 대한 설명으로 올바른 것은?
① 테스트 주도(Test-Driven) 프레임워크: Record & PlayBack을 지원하는 도구에서 주로
볼 수 있다.
② 데이터 주도(Data-Driven) 프레임워크: 키워드를 사용한 테스트 케이스를 이용하여 애
플리케이션 간에 결합을 줄여준다.
③ 선형(Linear) 프레임워크: 테스트 데이터 셋을 하드 코딩하지 않고 CSV 파일 등에 보관
하여 전달하면 테스트 효율을 높일 수 있다.
④ 모듈 기반(Module Based) 프레임워크: 하나의 큰 스크립트를 유지가 용이한 여러 개의
작은 스크립트로 분할하여 관리할 수 있다.

해설 :
①는 선형(Linear) 프레임워크에 대한 설명이다. 스크립트를 작성하는 가장 간단한 형태이다. 모듈과
같은 스크립트를 구조화하는 수단을 제공하지 않으며 스크립트의 테스트 단계들을 순차적인 흐름으로
실행한다. 이는 Record&Playback을 지원하는 도구에서 주로 찾아볼 수 있다.
②은 키워드 주도(Keyword-Driven) 프레임워크에 대한 설명이다.
③은 데이터 주도(Data-Driven) 프레임워크에 대한 설명이다. 테스트에 사용되는 데이터를 테스트 스
크립트의 로직과 분리하여 보관하는 프레임워크이다.

08 테스트 케이스를 컴퓨터가 실행할 수 있는 스크립트로 변환하는 방법 중 Record &
Playback 방식이 있다. [○/×]

해설 :
테스트 케이스를 컴퓨터가 실행할 수 있는 스크립트로 변환하는 방법 중에서 대표적인 것이 Record&
Playback 방식이다. 옳은 내용이다.
이 방식을 지원하는 도구는 사용자가 브라우저 등을 통해 시스템을 사용하는 행위와 시스템 반응을 스
크립트로 기록하고 이를 다시 반복 실행할 수 있도록 한다. 따라서 도구 사용자가 테스트 스크립트 언어
에 관한 특별한 지식이 없어도 테스트 케이스를 설계하여 실행할 수 있다. Katalon Studio는 Record&
Playback 기능을 제공하는 도구이다.

09 다음 중 테스트 자동화 도구로 가장 거리가 먼 것은?
① GUI 테스트 실행 도구(Selenium, Robotium)
② 소스 코드 빌드 도구(CMake, bitbake)
③ 테스트 관리 도구(Jenkins, Redmine)
④ 형상 관리 도구(Git, Subversion)

해설 :
② 빌드 도구는 테스트 자동화 도구로 보기 어렵다. (빌드 규칙을 서술한 텍스트 파일에 테스트 모듈을
포함하거나 수행하도록 기술하기는 하지만, 빌드 도구 자체가 테스트 자동화 도구로 보기는 어려움)

--
정답 07 ④ 08 ○ 09 ②
--

10 이슈 관리 도구를 이용하여 프로젝트에서 검출되는 결함을 관리하려고 한다. 결함이 식별
되고 완료되기까지의 이슈 상태를 추적하기 위해 다음 보기를 충족하는 결함의 생명 주기
를 설계하고 이를 상태 전이 다이어그램으로 표현하시오. (서답형/상태 간 전이는 단방향
화살표로 표현)
∙ 테스터는 테스트를 수행하여 결함을 식별하고, 결함에 관련된 정보를 기록한 이슈를 “Open”
상태로 등록한다.
∙ “Open” 또는 “Re-open” 상태의 이슈는 개발자에게 할당되며, 개발자는 이슈의 상태를 “In
progress”으로 변경한 후 분석 활동을 수행한다.
∙ 개발자는 소스 코드를 수정하고, 개발자 테스트를 수행하여 결함이 해결되었다고 판단한 후
테스터에게 재테스트를 요청하면서 이슈 상태를 “Resolved”로 변경한다.
∙ 테스터는 실제 결함이 해결되었는지 테스트하여 확인한다.
∙ 테스터는 재테스트를 수행한 후 보고된 결함이 제거되었다면 이슈의 상태를 “Closed”로 변
경하고, 기존 결함이 여전히 발견된다면 이슈의 상태를 “In progress”으로 변경한 후 개발자
에게 해결을 지시한다.
∙ 테스터는 “Closed” 상태의 이슈에 대해 동일한 결함이 재발되는 것을 확인하면 해당 이슈를
“Re-open” 상태로 변경한다.

![c7.ex10](csts/images/csts_7.ex10.png)

해설 :

일반적으로 이슈 관리 도구(예：Jira)는 원활한 
이슈 트래킹을 위하여 이슈 상태를 변경함으로써 이슈
의 생명 주기를 관리한다.
개발자/테스터/프로젝트 리더/고객 사이에 효과
적인 이슈 트래킹을 위해 현업에서 적극적으로
사용하는 도구이며, 이슈 트래킹을 자동화하는
데 매우 효과적인 도구이다.
본 문제에서는 테스터에 의한 신규 결함 보고
(Open)부터, 개발자에게 할당(In Progress),
해결 (Resolved), 최종 완료 (Closed) 그리고
리그레션이 발생으로 인한 결함 보고(Re-open)
에 이르는 이슈 생명 주기를 설계할 수 있는 역
량이 있는지 점검한다.

![c7.ex10-1](csts/images/csts_7.ex10-1.png)