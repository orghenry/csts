

# 제2편 테스트 설계기법

## 제8장 정적 테스트
## 제9장 구조 기반 테스트
## 제10장 명세 기반 테스트

--

# 제 8 장 정적 테스트

--

## 8.1 개요

소프트웨어 테스트 방법은 프로그램 실행을 요구하는 동적 테스트와 프로그램 실행을 요구하지 않는 정적 테스트로 분류한다.

IEEE 1028-2008에서는 정적 테스트를 리뷰(Review)라고 하며 다음과 같이 감사를 포함하여 5종류로 분류한다.

- 관리 리뷰(Management review)
- 기술 리뷰(Technical review)
- 인스펙션(Inspection)
- 워크쓰루(Walk-through)
- 감사(Audit)

--

## 정적 테스트의 중요성

리뷰는 여러 전문가가 모여 프로그램을 검토하여 결함을 검출하는 방법이다. 

리뷰 대상이 되는 작업물은 프로그램에 한정되지 않고 소프트웨어 개발 중에 생성되는 모든 산출물이 포함된다.

--

## 결함 제거 비용

프로그램 개발이 완료된 후 결함을 제거하는 일은 요구 단계나 설계 단계보다 100배 이상의 노력과 비용이 소요된다.

따라서 결함이 발생하는 순간 가능한 한 빨리 검출하여 제거해야 결함 제거 비용을 절약할 수 있다.

--

## 결함 제거 비용 절감

Tom Gilb은 리뷰를 이용하면 결함을 발견하고 제거하는 평균 비용을 60~80% 감소할 수 있다고 말한다. 

이는 전통적인 방법에 따른 소프트웨어 테스트 노력의 40%만으로도 테스트할 수 있고, 소프트웨어 개발 각 단계에서 다음 단계로 전이되는 결함의 50~70%를 감소시키는 효과가 있다는 것이다.


--

# 8.2 리뷰 프로세스

--

## IEEE 1028-2008의 리뷰 프로세스

IEEE 1028-2008에서는 1970년대 초 IBM에서 Fagan이 정립한 인스펙션 수행 프로세스에 기반을 둔 리뷰에 필요한 공통 프로세스를 제공한다.

프로세스를 구성하는 활동의 적용 수준은 리뷰의 종류에 따라 달라진다.

--

## 리뷰 프로세스 단계

### ① 경영진 준비(Management preparation)
- 경영진은 리뷰를 성공적으로 수행하기 위해 필요한 자원(스태프, 설비, 재원, 훈련 및 교육)을 제공하고 법규, 표준 및 관련 정책의 요구에 따른 리뷰 수행을 보장해야 한다.

--

### ② 리뷰 계획(Planning review)
- 리뷰 리더(Review leader)는 리뷰 목적을 파악해서 리뷰 팀을 구성하고 각 팀 구성원에게 책임을 할당한다.
- 또한, 리뷰 참가자들에게 리뷰에 필요한 자료들을 제공하고, 리뷰 일정을 결정하여 참가자들에게 공지한다.

--

### ③ 리뷰 절차 개요 설명(Overview of review procedures)
- 리뷰 리더의 요청에 따라 수행되며, 리뷰 목적과 절차를 설명한다.
- 반드시 리뷰 리더가 할 필요는 없고, 적절한 자격이 있는 사람이 수행할 수 있다.

--

### ④ 작업물 개요 설명(Overview of software product)
- 리뷰 리더의 요청에 따라 수행된다.
- 리뷰 참가자들이 검토할 작업물을 더 친숙하게 느끼고 사전 이해도를 높이기 위함이다.

--

### ⑤ 개별 준비(Individual preparation)
- 그룹 검토 전에 리뷰 팀 멤버들은 개별적으로 작업물이나 프로세스를 검토한다.
- 만약 검토 중에 문제를 발견하면 이를 문서화하여 리뷰 리더에게 보낸다.

--

### ⑥ 그룹 검토(Group examination)
- 계획된 날짜에 모든 리뷰 멤버들이 참석하는 회의를 진행한다.
- 여기서 모든 검토 결과를 모아 검토 대상의 상태에 대해 합의를 도출한다.

--

### ⑦ 재작업(Rework)
- 검출된 문제 목록을 개발자나 문제 해결 책임자에게 전달하여 문제를 해결한다.

--

### ⑧ 후속 작업(Follow up)
- 리뷰 리더는 회의에서 산출된 모든 조치 항목(Action item)을 완료했는지 확인한다.

--

## 리뷰 프로세스 조건

리뷰 프로세스를 수행하기 전에 리뷰를 위한 조건(Entry condition)을 만족했는지 확인해야 하며, 리뷰 후에도 성공적인 리뷰를 위한 모든 행위가 수행되었는지 확인해야 한다.

--

# 8.3 관리 리뷰

## 관리 리뷰의 목적
- 관리 리뷰의 목적은 진행 상황을 모니터하고, 계획과 현재 일정 상태를 평가하여 필요 시 자원, 일정, 프로젝트 범위 등을 변경하는 것이다.
- 관리 리뷰 후에는 해당 계획이 적절히 변경되었는지 확인할 필요가 있다.

--

## 관리 리뷰 대상 작업물
관리 리뷰 대상이 되는 작업물은 다음과 같다:
- 설치 계획
- 백업 및 회복 계획
- 안정성 계획
- 재난 계획
- 비상 대책 계획(Contingency plan)
- 진행 보고서
- 테스트 결과

--

## 관리 리뷰의 프로세스
관리 리뷰는 **8.2절**에 기술한 리뷰 프로세스를 따른다.
- 그러나 **④ 작업물 개요 설명** 단계는 수행되지 않는다.
- 그룹 검토 회의는 관리 스태프들이 참여하며, 관리자가 주재한다.
- 기술 스태프는 관리 스태프에게 필요한 정보를 제공해야 한다.

--

## 관리 리뷰에서의 역할
- 리뷰팀이 발견한 문제, 조치 사항, 결정 사항 및 추천들은 **서기(Recorder)**가 기록한다.
- 조치 항목 목록, 문제(Anomaly list) 등은 **의사 결정자(Decision maker)**에게 전달된다.
- 리뷰 목적이 달성되었는지 판단한다.
- 산출물들은 검토 회의 결과에 영향을 받는 사람들에게 전달되어야 한다.

--
# 8.4 기술 리뷰

## 기술 리뷰의 목적
기술 리뷰는 유능한 인력으로 구성된 팀이 프로젝트의 기술적 상태를 확인하고, 다음 작업을 수행하여 관리자에게 제공하는 과정이다:

- 대상 작업물이 의도된 사용에 적합한지 평가한다.
- 대상 작업물이 계획, 법규, 표준, 명세를 충실히 지키는지 평가한다.
- 변경 사항이 적절히 구현되었는지를 평가하고, 변경 명세에 식별된 영역에만 영향을 미치는지 평가한다.
- 여러 대안을 추천하거나 대안들을 검토한다.

--

## 기술 리뷰 대상 작업물
기술 리뷰의 대상에는 다음이 포함되지만 이에 한정되지는 않는다:
- 소프트웨어 요구 및 설계 명세
- 테스트 문서
- 유지 보수 매뉴얼
- 설치 절차

--

## 기술 리뷰의 프로세스
기술 리뷰는 **8.2절**에 기술한 리뷰 프로세스를 따른다. 
- **대표 엔지니어(Lead engineer)**가 주재하며, 필요한 경우 관리자도 참가할 수 있다.
- 관리자가 해결해야 할 이슈가 있을 경우, 관리자가 참여하여 이슈를 처리한다.


--
# 8.5 인스펙션

## 인스펙션의 정의
인스펙션(Inspection)은 IEEE 1028-2008의 리뷰 종류 중에서 가장 형식화된 대표적인 리뷰 방식이다. IBM의 Fagan은 결함을 발생한 시점에서 가능한 한 이른 시기에 제거해야 하며, 이를 위해 구조적이고 절차적인 방법이 필요하다는 생각을 기반으로 인스펙션 프로세스를 정립하였다.

--

## 동료 검토(Peer review)
- 인스펙션은 **동료 검토(Peer review)**의 일종으로, 비슷한 수준이나 역할을 가진 사람들이 소프트웨어 산출물을 검토하는 작업이다.
- 주로 **코드**를 포함한 소프트웨어 산출물들이 검토 대상이 된다.

--

## 인스펙션의 특징
- 가능한 한 개발 초기 단계에서 검사를 진행하여 초기 작업물에서 문제를 찾아낸다.
- 검출된 문제(Anomaly)의 유형과 투자한 시간 등을 포함한 자료를 수집하여, 이후 인스펙션 프로세스와 체크리스트 같은 인스펙션 지원 문서 개선에 활용된다.


--
# 8.5.1 인스펙션 참가자의 역할

## 인스펙션 과정 이해
인스펙션 과정을 올바르게 이해하면 자원과 시간의 낭비를 줄일 수 있다. 이를 위해 참가자의 역할을 이해하는 것이 중요하다.

--

## 주재자(Inspection Leader/Moderator)
- **주된 임무**: 검사할 작업물을 기초로 인스펙션 참가자 선정 및 인스펙션 계획 수립.
- **검토 준비**: 인스펙션 자료를 미리 전달하여 회의 준비를 돕는다.
- **회의 진행**: 참가자 간 불화나 예기치 않은 상황에 잘 대처하고 후속 조치를 결정한다.
- **회의 후**: 기록된 자료를 보고서 형식으로 작성하여 개발자에게 전달하고, 인스펙션 데이터를 수집하여 프로세스 개선에 활용.

--

## 작성자(Author)
- **임무**: 인스펙션 회의에 필요한 자료 제출 및 설명.
- **참여**: 회의 내용에 신중히 참여하며 방어적인 자세를 피한다.
- **재작업**: 검출된 결함에 대해 재작업을 수행한다.
- **주의**: 작성자는 인스펙션 주재자가 될 수 없다.

--

## 낭독자(Reader)
- **임무**: 작업물을 회의 참가자에게 설명하며 인스펙션 회의를 이끈다.
- **효율적 진행**: 작업물을 여러 부분으로 나누어 각 낭독자에게 할당하여 회의를 진행할 수 있다.

--

## 기록자(Recorder)
- **임무**: 회의 중 논쟁, 질문, 답변 등을 기록한다.
- **회의 후**: 기록된 사항을 정리하여 문서화한다.
- **참여**: 기록자는 검토자로서 회의에 참여하며, 회의 주재자나 개발자 역할은 하지 않는다.

--

## 검토자(Inspector)
- **임무**: 전달받은 자료를 충분히 검토하고 결함을 찾아 기록한다.
- **특별 주제 할당**: 특정 표준이나 철자 오류에 중점을 두고 리뷰할 수 있다.
- **객관적 참여**: 의견을 제시하되, 해결자는 아니므로 결함을 해결하려 하지 않는다.
- **주의**: 관리자는 팀 멤버로 참여할 수 없다.

--
# 심화노트: 퍼실리테이터와 이상적인 인스펙션 팀 규모

## 퍼실리테이터(Facilitator)
- **역할**: 여러 사람이 일정한 목적을 가지고 작업을 수행할 때, 그 과정이 효과적으로 이루어지도록 돕는 사람.
- **임무**: 
  - 작업 과정을 설계하고 참여를 유도하여 높은 품질의 결과물이 나오도록 지원.
  - 검토 회의나 워크숍에서 효과적인 참여를 이끌어냄.

--

## 이상적인 인스펙션 팀의 규모
- **팀 최소 구성**: 작성자가 자신의 작업물을 비평할 수 없으므로, 작성자 이외에 검토자가 최소 1명 이상 있어야 하며, 주재자도 필요하다.
- **최적 팀 규모**: 4명. 3~6명이 이상적인 팀 규모로, 6명 이상은 관리가 어려워 비효율적.
- **팀 역할**: 주재자 외에도 모든 팀원은 검토자 역할을 수행한다.

--

## 팀 구성 시 중요한 점
- **목표**: 인스펙션의 목적은 작성자의 능력을 평가하는 것이 아니라 작업물에서 결함을 찾아 품질을 향상시키는 것이다.
- **팀의 인식**: 팀원 모두가 이 목표를 공유하고, 작성자를 평가하는 분위기가 형성되지 않도록 주의해야 한다.


--
# 8.5.2 인스펙션 과정

## 인스펙션 과정 개요
인스펙션은 8.2절에서 설명한 리뷰 프로세스를 따르며, 각 단계는 다음과 같다.


## ① 리뷰 계획 (Planning review)
- **중재자 역할**: 리뷰 목적 파악 후 팀 구성 및 역할 할당.
- **참가자 통지**: 리뷰 날짜, 장소 등을 참가자에게 알림.
- **준비 시간 제공**: 참가자들에게 필요한 자료와 준비 시간을 제공.

--

## ② 인스펙션 절차 개요 설명 (Overview of inspection procedures)
- **중재자 역할**: 참가자들에게 역할 할당 및 질문에 답변.
- **전달 사항**: 최소 준비 시간, 인스펙션 수행률, 과거 프로젝트에서 발견된 문제 수 등 전달.


## ③ 인스펙션 작업물에 대한 개요 설명 (Overview of inspection product)
- **작성자 역할**: 검토할 작업물을 설명.
- **목표**: 참가자들이 작업물을 친숙하게 느끼도록 하고, 사전 이해도를 높임.
- **주의사항**: 해결책 제시나 결함 수정은 하지 않음.

--

## ④ 준비 (Preparation)
- **검토 활동**: 인스펙션 팀 구성원은 실제 회의 전 작업물을 검토.
- **문제 분류**: 검출된 문제는 중재자에게 전달되어 적절하게 분류.
- **심각한 문제**: 문제가 너무 많거나 심각하면 인스펙션을 취소할 수도 있음.


## ⑤ 검토 회의 (Inspection meeting)
- **회의 개시**: 개별 검토 후, 낭독자가 작업물 설명.
- **검토 활동**: 참가자들이 철저하고 객관적으로 작업물을 검사.
- **작성자 역할**: 질문에 답하며 결함 검출을 돕되, 옹호하거나 설명하는 행위는 피함.
- **결과 분류**:
  - **Accept with no verification or with rework verification**: 승인 또는 간단한 재작업 후 승인.
  - **Accept with rework verification**: 주재자가 재작업을 검증한 후 승인.
  - **Reinspect**: 문제가 해결된 후 재검토.

--

## ⑥ 재작업 (Rework)
- **작업**: 작성자는 검출된 문제를 해결하는 작업을 수행.
- **작업 예시**: 코드 수정, 주석 추가/제거, 구조 재구성 등.
- **주의사항**: 문제 해결 방안에 대한 논의는 검토 회의 중에 하지 않음.

## ⑦ 후속작업 (Follow up)
- **검토 후 작업**: 주재자 또는 위임된 사람이 문제 해결 여부를 확인.
- **목표**: 재작업이 충분히 이루어졌는지 검토.

--
# 8.6 워크쓰루


## 워크쓰루 개요
워크쓰루(Walkthroughs)는 인스펙션보다 비형식적인 결함 검출 방법으로, 결함을 검출하는 것 외에도 참가자들의 교육과 지식 공유를 위해 수행된다.

--

## 워크쓰루와 인스펙션의 차이점
- **인스펙션**: 회의 주재자는 작성자가 아닌 사람이 맡는다.
- **워크쓰루**: 작성자가 회의를 주재하며, 기록자 역할도 담당할 수 있다.


## IEEE 1024-2008 기준
- 워크쓰루 절차와 작업물에 대한 개요 설명을 워크쓰루 회의의 일부로 다룰 수 있음.
- 작성자가 작업물을 따라 돌아다니며 설명하고 결함을 검출하는 방식.

--

## 워크쓰루 과정
1. **설명**: 작성자는 작업물에 대해 설명을 진행.
2. **결함 검출**: 참가자들은 결함을 찾고 권고 사항을 기록.
3. **재작업**: 작성자는 결함을 해결하고 모든 조치 사항이 완료되었음을 확인.


## 주의사항
- **관리자 직책**: 팀의 관리자는 워크쓰루 팀에 참여하지 않는다.

--
# 8.7 감사


## 감사의 목적
IEEE 1028-2008에서는 감사(Audit)의 목적을 소프트웨어 제품 및 프로세스가 **규제**, **표준**, **가이드라인**, **계획**, **절차**를 준수하고 있는지 독립적으로 평가하는 것으로 규정.


## 감사 참여자 역할
- **대표 감사자(Lead auditor)**: 감사를 주도하며 인터뷰 및 문서 점검
- **감사자(Auditor)**: 감사를 수행
- **기록자(Recorder)**: 감사 기록
- **개시자(Initiator)**: 감사 시작

--

## 감사 절차
1. **감사 주도**: 대표 감사자가 법규나 표준 부합 여부를 검토.
2. **증거 수집**: 인터뷰 및 문서 점검을 통해 증거 수집.
3. **비준수 사항 식별**: 비준수 사례를 찾아 교정 활동을 요구.
4. **보고서 작성**: 감사 보고서를 산출.

--

# 8.8 정적 분석


## 정적 분석 개요
정적 분석(Static analysis)은 **자동화 도구**를 사용하여 소프트웨어 코드에서 결함을 찾는 방법.


## 정적 분석 도구
- **컴파일러**: 문법 결함 및 무한 루프 등 기본적인 결함 검출
- **기타 도구**: 코드 복잡도 계산, 자료 흐름 분석

--

## 정적 분석의 장점
- **효율성**: 많은 작업을 자동으로 처리 가능.
- **검출 항목**: 코딩 표준 부합, 코드 복잡도, 자료 흐름 분석 등.

--

# 8.8.1 코딩 표준


## 코딩 표준(Coding standard) 개요
- **코딩 표준** 또는 **코딩 지침**은 개발자가 프로그램을 작성할 때 지켜야 하는 규약.
- **목적**: 일관되게 프로그램을 작성하여 가독성 향상, 유지보수 용이성 증가.

--

## 코딩 스타일의 예
- **주석문**: 언제/어떻게 주석을 추가할지
- **변수 및 함수 이름**: 이름 규칙
- **들여쓰기**: 코드 들여쓰기 방법
- **switch 문**: default 문 추가 여부


## 코딩 표준의 중요성
- 여러 개발자가 협력하여 작성하더라도 프로그램이 동일한 개발자가 작성한 것처럼 보이도록 함.
- **효과**: 가독성 향상, 이해도 증가, 유지보수 용이성.

--

예를 들어 그림 8.1의 프로그램을 보자.

```c
int foo(int n) { int i = 0; while (n > 0) {i = i + n % 10;
n = n / 10;
} return i;}
```
그림 8.1 코딩 표준을 적용하기 전 프로그램

이 코드를 개발한 당사자도 한 달 후 아니 일주일 후에 코드를 보면 무슨 코드인지 이해하
는 데 어려움이 따를 것이다.
그림 8.2의 코드는 위 코드를 구글(Google)의 자바(Java) 코딩 표준(심화노트 참고)을 따라
다시 작성한 것이다. 코딩 표준을 적용하기 전보다 가독성이 훨씬 좋아졌음을 알 수 있다.

```c
public static int foo(int n) {
    int i = 0;
    while (n > 0) {
        i = i + n % 10;
        n = n/ 10;
    }
    return i;
}
```
그림 8.2 구글 자바 코딩 스타일에 따라 개선한 프로그램

--
![alt text](csts/images/csts_table_8.a0.png)

# 심화노트: 코딩 스타일


## 중괄호 위치에 따른 스타일
- 중괄호의 위치는 주로 **BSD**, **K&R**, **GNU** 3가지 스타일로 구분됨.
- **구글 자바 코딩 스타일**: K&R 스타일을 따름.

--

## 들여쓰기 규칙
- 새로운 블록은 **공백 두 칸**으로 들여쓰기 시작.
- 블록 종료 후, **이전 들여쓰기 수준**으로 되돌아감.

--

## 메소드 이름 규칙
- **카멜 표기법(Camel Case)** 사용.
- 동사나 동사구를 메소드 이름으로 사용.
- 카멜 표기법: 첫 단어는 소문자, 이후 단어 첫 글자는 대문자.

--

## 변수 이름 규칙
- **카멜 표기법(Camel Case)** 사용.
- **명사**를 사용하여 변수 이름 작성.
- 변수 이름은 의미를 드러내고 사용 의도를 나타내야 함.

--

## 개선된 코드 예시
- 함수 이름과 변수 이름은 사용 의도를 명확하게 드러내도록 작성되어야 한다.
- 이 점을 반영하여 **가독성**을 높인 코드를 개선.



실제
이 프로그램은 정수를 입력으로 받아 정수를 구성하는 숫자들의 합을 구하는 프로그램이다.
```c
public static int getSumOfDigits(int n) {
    int sum = 0;
    while (n > 0) {
        sum = sum + n % 10;
        n = n/ 10;
    }
return sum;
}
```
그림 8.3 함수 이름과 변수 이름을 개선한 프로그램

--
# MISRA-C: 안전성 및 신뢰성을 위한 코딩 가이드라인


## MISRA-C 소개
- **MISRA-C**: 영국 자동차 산업 신뢰성 협회(MISRA)에서 발표한 C 프로그래밍 언어의 코딩 가이드라인.
- **목적**: 임베디드 시스템에서 **안전하고**, **이식성이 좋고**, **신뢰성 있는 코드**를 작성하는 것.

--

## MISRA-C의 발전
- **1998**: MISRA-C 첫 발표.
- **MISRA-C:2004**: 자동차 등 안전성 요구 분야에 맞게 개정판 발표.
- **MISRA-C:2012**: 2013년 3월 발표.

--

## C 언어의 안전성 문제
- **C 언어**는 임베디드 시스템 개발 시 선호되지만, **안전성**이 중요한 시스템에서는 주의가 필요.
- **문제 원인**: C 언어의 "undefined behavior"가 문제를 일으킬 수 있음.

--

## undefined behavior
> **ISO/IEC 9899-2011** 정의:
> "호환이 안 되거나 잘못된 프로그램 구조나 데이터의 사용으로 인한 동작. 본 국제표준은 어떤 요건도 부과하지 않음."

> **MISRA-C** 정의:
> "본질적으로 프로그래밍 오류, 하지만 컴파일러 개발자는 반드시 오류 메시지를 제공할 의무가 없음."


--

다음은 “undefined behavior”가 발생할 수 있는 경우이다.
∙ 초기화되지 않은 변수의 사용
∙ 배열의 범위를 넘어서는 인덱스를 사용하여 배열 참조
∙ 0으로 나눗셈 연산 수행

예를 들어, 그림 8.4 프로그램을 살펴보자.

```c
int x;
if (x == 1) printf("Hello");
if (x == 2) printf("World!!!");
```
그림 8.4 “undefined behavior”가 발생하는 코드

--
# MISRA-C: 자동 변수 초기화 및 정적 분석 도구

## 정의되지 않은 동작 (Undefined Behavior)
- **예시 코드**: 초기화되지 않은 정수형 변수 `x`를 사용하는 코드.
- **일반적인 생각**: 코드가 "Hello"나 "World!!!"를 출력할 것으로 예상됨.
- **실제 동작**: C 언어 명세에서는 이 코드에 대해 컴파일러가 생성하는 코드에 요구사항이 없으므로, 출력 내용은 예측 불가.
- **결과**: "Hello"와 "World!!!"가 함께 출력될 수도 있고, 더 심각하게는 시스템에 심각한 영향을 미칠 수 있음.

--

## MISRA-C 목표
- **주요 목표**: "undefined behavior"에 의존하지 않은 안전한 프로그램 개발.
- **규칙 예시**: MISRA-C:2004에서는 자동 변수가 사용되기 전에 값이 할당되지 않으면 안 된다고 규정.


## Rule 9.1
> **Rule 9.1**: All automatic variables shall have been assigned a value before being used.
> - 모든 자동 변수는 사용되기 전에 값을 할당받아야 한다.

--

## 자동화된 정적 분석 도구
- **정적 분석 도구**: MISRA-C 규칙을 자동으로 검사하여 오류를 줄이고, 개발자가 수작업으로 검사하는 번거로움을 줄여줌.
- **대표적인 도구**:
  - **LDRA**
  - **PRQA**
  - **Parasoft**
  - **Suresoftetch** (국내 제품)

--
# 순환 복잡도 및 복잡도 분석

--

## 복잡도 분석
- **목표**: 소프트웨어 개발에서 프로그램의 복잡도를 통제하여 신뢰성, 테스트 비용, 유지보수성을 개선.
- 복잡도가 높을수록 프로그램의 신뢰성, 테스트 비용, 유지보수성이 나빠질 수 있음.
- **복잡도 척도**: 복잡도를 측정하기 위한 신뢰할 수 있는 척도를 사용하는 것이 중요.

--

## 순환 복잡도 (Cyclomatic Complexity)
- **발표자**: McCabe (1976)
- **정의**: 프로그램의 제어 흐름 그래프에서 선형적으로 독립적인 기본 경로(Basis path)의 개수.
- **특징**: 이 기본 경로 집합을 사용하여 모든 경로를 선형적으로 조합할 수 있음.
- **순환 복잡도 계산식**: 
  $$
  \text{순환 복잡도} = E - N + 2
  $$
  - \(E\): 제어 흐름 그래프에 있는 간선의 개수
  - \(N\): 제어 흐름 그래프에 있는 노드의 개수

--

## 예시
- **제어 흐름 그래프에서**:
  - \(E = 8\), \(N = 7\)
  - 순환 복잡도: \(8 - 7 + 2 = 3\)

--

## 순환 복잡도의 중요성
- 순환 복잡도가 높을수록 프로그램의 복잡도가 높아짐.
- 복잡도가 높으면 **신뢰성**, **유지보수성**, **테스트 비용**에 부정적인 영향을 미칠 수 있음.


![그림 8.6 제어 흐름 그래프에 존재하는 영역](csts/images/csts_8.5.png)

--
# 순환 복잡도 및 제어 흐름 그래프의 영역

--

## 순환 복잡도와 제어 흐름 그래프의 관계
- **순환 복잡도**는 제어 흐름 그래프의 **닫힌 영역(Region)** 개수와 관계가 있음.
- 제어 흐름 그래프에서 종료 노드에서 시작 노드로 간선을 연결하면 그래프가 여러 개의 **닫힌 영역**으로 분할됨.
- **순환 복잡도**는 이 **닫힌 영역**들의 개수에 따라 결정됨.

--

## 닫힌 영역을 이용한 순환 복잡도 계산
- 순환 복잡도를 계산하려면 **닫힌 영역의 개수**를 이용.
- 계산 공식:
  $$
  \text{순환 복잡도} = \text{닫힌 영역의 개수} + 1
  $$

--

## 예시
- **제어 흐름 그래프** (그림 8.5에 대한 예시)
  - 닫힌 영역 2개 존재.
  - 순환 복잡도: \( 2 + 1 = 3 \)

--

## 순환 복잡도와 닫힌 영역
- 닫힌 영역은 **제어 흐름 그래프** 내에서 **자기완결적**인 루프를 형성하는 부분들.
- 순환 복잡도가 높을수록 코드의 **복잡도**와 **유지보수 어려움**이 증가할 수 있음.


![그림 8.6 제어 흐름 그래프에 존재하는 영역](csts/images/csts_8.6.png)

--

# 순환 복잡도 계산의 간소화

## 순환 복잡도 계산 간소화
- **순환 복잡도**는 제어 흐름 그래프의 **분기 노드** 개수에 **1**을 더하여 계산할 수 있음.
  $
  \text{순환 복잡도} = \text{분기 노드들의 개수} + 1
  $
- 예시: 그림 8.5에서 순환 복잡도는 3.

--

## 순환 복잡도와 프로그램의 이해도
- 순환 복잡도는 프로그램을 **이해하고, 테스트하고, 유지보수하는** 어려움을 평가하는 기준이 될 수 있음.
- 높은 순환 복잡도는 **결함률 증가**와 관련 있음.

--

## 순환 복잡도와 신뢰성
- **Walsh** (1979) 연구에 따르면, **순환 복잡도**가 **10 이상**일 때 결함률이 급격히 증가.
- **Audi, BMW, Porsche, Volkswagen, Chrysler** 등은 순환 복잡도를 **10 이하로 유지**할 것을 권고.
- **JSF (Joint Strike Fighter)**는 **20 이하**를 권장, **MISRA Report 5**는 **15 이하**를 권장.

--

## 순환 복잡도와 소프트웨어 신뢰성
- **Carnegie Mellon University**의 SEI는 순환 복잡도가 높을수록 **위험성(Risk)**이 증가한다고 언급.
- **RIAC**에서는 복잡도와 신뢰성의 관계를 아래와 같이 제시.

![순환 복잡도와 신뢰성 관계](csts/images/csts_table_8.1.png)


--
심화노트 : 순환 복잡도 계산

만약 분기 노드가 여러 개의 조건문으로 구성되어 있을 때 순환 복잡도를 어떻게 계산할까? 예를 들
어, 다음 프로그램의 순환 복잡도를 계산해보자.
```c
if ((x>0) && (y>0)) {
doSomething1;
}
doSomething2;
```
이 프로그램의 제어 흐름 그래프는 다음과 같다.

![alt text](csts/images/csts_8.a1.png)

이 그래프에서 순환 복잡도를 산출해보자. E-N+2=3-3+2이므로 순환 복잡도는 2이다. 그러나 분
기 노드가 복합 조건식이므로 이를 감안하여 계산할 필요가 있다. 또한, 단축연산을 수행할 경우에
는 예제 프로그램은 아래와 같이 변환된다.
```c

if (x>0) {
if (y>0)
doSomething1;
}
doSomething2;
```

이 프로그램에 해당하는 제어 흐름 그래프는 다음과 같다.

![alt text](csts/images/csts_8.a2.png)


# 순환 복잡도 계산 및 자료 흐름 분석

## 순환 복잡도 계산

순환 복잡도는 프로그램의 제어 흐름을 분석하여, 복잡도를 측정하는 중요한 지표입니다. 일반적인 규칙은 다음과 같습니다:

- **if, while, for, &&, ||** 조건문이나 논리 연산자들이 등장할 때마다 +1을 추가합니다.
- **switch 문**의 각 **case**마다 +1을 추가하는 경우가 있습니다. 그러나 일부에서는 `switch` 문 자체에 대해서만 +1을 추가하고, 각 **case**는 고려하지 않는 경우도 있습니다.

### 예시
- 제어 흐름 그래프에서 **E-N+2** 공식을 이용해 순환 복잡도를 계산할 수 있습니다.
- 예를 들어, **E = 5, N = 4**이면, 순환 복잡도는 **5 - 4 + 2 = 3**이 됩니다.

## 자료 흐름 분석

자료 흐름 분석(Data flow analysis)의 주요 목적은 프로그램 내에서 변수들의 흐름을 분석하여, 이상(anomaly)을 찾아내는 것입니다. 예를 들어, 변수 정의가 되지 않은 상태에서 변수를 사용하는 오류를 감지할 수 있습니다.

### 예시 코드
```c
int x;
if (x == 1000) { … }
```

## 변수 초기화 문제와 자료 흐름 분석

### 변수 초기화 문제
예시 코드에서 **x**는 선언되었지만 초기화되지 않았습니다. 이 상태에서 **x**를 조건문에서 사용하려고 하면, **x**는 값이 정의되지 않았기 때문에 오류가 발생할 수 있습니다. 이 문제는 **자료 흐름 분석(Data Flow Analysis)**을 통해 감지할 수 있습니다.

### 기본적인 자료 흐름 이해
자료 흐름 분석에서는 프로그램 내에서 변수의 상태 변화를 추적하며, 변수의 정의와 참조, 무효화 상태를 파악합니다:

- **정의(Defined, d)**: 변수에 값이 할당된 상태입니다. 예를 들어, `x = 100;`에서 `x`는 정의되었습니다.
- **참조(Used, u)**: 변수의 값을 읽거나 계산에 사용되는 경우입니다. 예를 들어, `if (x > 0)`에서 `x`는 참조되고 있습니다.
- **무효화(Killed, k)**: 변수가 더 이상 유효하지 않거나 사용되지 않게 되는 상태입니다. 예를 들어, 함수 종료 후 변수는 무효화됩니다.

### 자료 흐름 분석의 기호
자료 흐름 분석에서 다음과 같은 기호를 사용하여 변수의 상태를 나타냅니다:

- **d**: 변수는 정의된 상태입니다.
- **k**: 변수는 무효화된 상태입니다.
- **u**: 변수는 참조된 상태입니다.
- **~x**: 변수 **x**와 관련된 선행 행위가 없음을 나타냅니다. 즉, **x**의 정의나 참조가 없음을 의미합니다.
- **x~**: 변수 **x** 이후의 행위들이 **x**와 관련이 없음을 나타냅니다. 즉, **x**의 정의나 참조 이후, 더 이상 **x**가 사용되지 않음을 의미합니다.

--
## 자료 흐름 쓰임새 패턴

### 표 8.2: 자료 흐름 쓰임새 패턴

자료 흐름 분석을 통해 변수의 정의, 참조, 무효화 상태를 추적할 수 있습니다. 하지만 모든 자료 흐름 패턴이 이상 현상을 일으키는 것은 아니며, 일부 패턴은 잠재적인 결함을 나타낼 수 있습니다. 예를 들어, **'ku'** 쓰임새 패턴은 변수가 무효화된 후에 다시 사용되는 경우로, 이는 심각한 결함을 초래할 수 있습니다.

![표 8.2 자료 흐름 쓰임새 패턴](csts/images/csts_table_8.2.png)

### 자료 흐름 패턴 분석 예시

그림 8.7에 주어진 프로그램에서 변수 **a**에 대한 자료 흐름 패턴을 살펴보겠습니다. 예제 프로그램에서 **2번 문장**과 **3번 문장**에서 연속적으로 **a**가 정의되고 있음을 알 수 있습니다. 이와 같은 패턴은 변수에 대한 정의가 중복되거나 잘못된 방식으로 이루어졌음을 의미할 수 있습니다. 자료 흐름 분석을 통해 이러한 중복 정의를 추적하고, 의도하지 않은 오류를 예방할 수 있습니다.

--

나머지 패턴들은 모두 정상적인 경우를 보여 준다.

```c
1: int dataflow(int c, int d) {
2: int a=0, x;
3: a = c+d;
4: if (a>0)
5: x = 1;
    else
6: c = 10;
7: a = a+x;
8: return a;
9:}

```
그림 8.7 예제 프로그램

![표 8.3 변수 a에 대한 예제 프로그램의 자료 흐름 패턴](csts/images/csts_table_8.3.png)

--
## 자료 흐름 패턴 분석

### 상태 그래프를 통한 자료 흐름 분석

자료 흐름 분석에서는 변수의 상태를 추적하고, 이를 통해 프로그램에서 발생할 수 있는 이상을 찾아냅니다. 상태 그래프는 변수의 상태를 나타내는 노드와 상태 간의 전이를 나타내는 간선으로 구성됩니다. 각 노드는 변수의 상태를 의미하며, 노드 간의 간선은 상태 간의 변화를 나타냅니다.

### 예시: 'uu' 패턴

그림 8.8은 자료 흐름 패턴을 입력으로 받아 이상 여부를 확인하는 상태 그래프를 보여 줍니다. 이를 통해 변수의 흐름과 이상을 추적할 수 있습니다.

- **'uu' 패턴**: 변수 **a**에 대해 'uu' 패턴을 보여 주는 부분 경로 **4-5-7**을 예로 들어 봅시다.
  - **4번 문장**: 변수 **a**는 조건식에서 참조되므로 상태 그래프에서 'U'(참조) 상태로 시작합니다.
  - **5번 문장**: 변수 **a**를 정의하거나 참조하지 않으므로 상태는 여전히 'U' 상태로 유지됩니다.
  - **7번 문장**: 변수 **a**를 다시 참조하므로, 상태 그래프에서 다시 'U' 상태로 전이가 이루어집니다.

이와 같은 상태 전이를 추적함으로써 변수의 상태를 점검하고, 코드 내에서 발생할 수 있는 이상을 사전에 파악할 수 있습니다. 상태 그래프는 특히 **'ku'**와 같은 잠재적인 결함을 파악하는 데 유용합니다.


--

![그림 8.8 자료 흐름 이상 상태 그래프](csts/images/csts_8.8.png)

표 8.4는 변수 x에 대한 자료 흐름 쓰임새 패턴을 보여 주며 변수 x가 정의되지 않았는데도
사용되는 자료 흐름 이상을 검출하였다.

![표 8.4 변수 x에 대한 예제 프로그램의 자료 흐름 이상](csts/images/csts_table_8.4.png)


--
Exercise

--

01 요구사항 분석서, 설계서, 코드, 테스트 관련 문서 등 소프트웨어 개발 관련 모든 문서와
산출물이 리뷰 대상이 될 수 있다. [○/×]
해설 :
리뷰 대상이 되는 작업물은 프로그램에 한정되지 않고 소프트웨어 개발 중에 생성되는 모든 산출물이
다. 즉, 요구사항 명세서, 설계 명세서, 테스트 계획서와 같은 문서들이 올바르게 작성되었는지를 판단
하기 위해 리뷰 방법을 이용할 수 있다.

--

02 다음 중 감사(Audit)의 목적을 가장 잘 설명한 것은?
① 대상 작업물이 계획, 법규, 표준이나 명세를 충실히 지키는지를 평가한다.
② 소프트웨어 제품 및 프로세스가 규제, 표준, 가이드라인, 계획, 절차를 준수하고 있는지
평가한다.
③ 개발자가 작성한 소스코드가 코딩표준 또는 코딩 지침에 맞게 작성되었는지 검토한다.
④ 현재 계획에 따라 진행 상황을 모니터하여 계획과 일정 상태를 평가하여 필요하다면 자
원, 일정이나 프로젝트 범위 등을 변경한다.

해설 : 
감사(Audit)의 목적은 소프트웨어 제품 및 프로세스가 규제, 표준, 가이드라인, 계획, 절차를 준수하고
있는지를 독립적으로 평가하는 것이다. (IEEE 1028-2008)

--

03 기술 리뷰는 관리자 직책을 담당하는 사람이 팀의 멤버로 참여하는 것을 금지하고 있다.
[○/×]

해설: 기술 리뷰는 대표 엔지니어(Lead engineer)가 주재를 하며 경우에 따라 관리자가 해결해야 할 이슈가
있으면 관리자도 참가할 수 있다.

04 정적 분석을 통해 식별할 수 있는 결함 유형과 거리가 먼 것은?
① 초기화하지 않고 사용한 변수
② 선언 후 사용하지 않은 함수
③ 선언 후 사용하지 않은 변수
④ 요구사항과 다른 연산 결과

해설 : 
도구의 지원을 받아 정적테스트를 수행하는 것을 정적 분석이라고 한다. 정적분석으로 식별할 수 있는
결함은 초기화하지 않고 사용한 변수, 선언 후 사용하지 않은 함수, 선언 후 사용하지 않은 변수 등이다.

--

정답 01 ○ 02 ② 03 × 04 ④

--

05 다음 프로그램 코드는 K&R 코딩 스타일을 따른다. [○/×]
if (x == 1){
프로그램 문장;
}
중괄호의 위치에 따른 코딩 스타일에는 다음과 같이 대표적으로 BSD, K&R, GNU 3가지가 있다.

![alt text](csts/images/csts_table_8.a0.png)

K&R은 여는 블록을 if와 같은 행에 배치한다. 코드 줄 수를 절약하여 한눈에 많은 코드를 볼 수 있고
수평으로 많은 코드를 작성할 수 있다.

--

정답 05 ○

--

06 다음의 자료 흐름도에서 변수 x에 대한 오류 패턴을 하나만 적으시오.

![alt text](csts/images/csts_8.ex06.png)

--
정답 06 kk

--
07 다음 프로그램에 대해 자료흐름 분석을 수행하여 검출되는 자료 패턴 중에서 잠재적 오류
인 패턴은 무엇인가?

```c
int foo(int x) {
    int y;
    if (x==1)
        y=x+1;
    x=10;
    return y;
    y=10;
}
```
① ~u ② du
③ uu ④ ~k

![alt text](csts/images/csts_8.ex07.png)

--
08 리뷰(Review, 검토)를 성공시키기 위해 필요한 요소로 가장 거리가 먼 것은?
① 리뷰 주재자가 리뷰 기법에 대한 교육을 이수한 경우, 리뷰 참석자는 별도의 교육이 필요
하지 않다.
② 소프트웨어 개발 산출물과 검토자의 수준 등을 고려하여 리뷰 기법을 적절히 적용해야 한다.
③ 결함의 발견에 부정적이지 않으며, 발견된 결함은 객관적으로 표현되어야 한다.
④ 효과적이고 효율적인 결함 발견을 위해 필요 시 체크리스트를 활용할 수 있다.

해설 : 
① 리뷰 참석자는 리뷰 기법에 대한 교육 훈련이 제공되어야 하며, 주재자는 별도의 교육을 필수로 
이수 해야 한다.

--
정답 07 ① 08 ①

--

09 다음 중 테스트 실행에 대한 설명으로 올바른 것은?
① 테스트를 실행하는 주체는 테스트 단계(레벨)에 따라서 달라질 수 있다.
② 컴포넌트 테스트는 사용자가 직접 실행시키는 것이 일반적이다.
③ 인수 테스트는 원칙적으로 운영 환경에서 개발자에 의해 실행된다.
④ 통합 테스트는 개발 환경에서 시스템 테스트 완료 후에 수행한다.

해설:
② 컴포넌트 테스트는 개발자가 직접 실행시키는 것이 일반적이다.
③ 인수 테스트는 원칙적으로 사용자의 환경에서 사용자에 의해서 실행이 된다.
④ 통합 테스트는 개발 환경에서 컴포넌트 테스트 후에 수행한다.

--

10 인스펙션(Inspection)을 도입하여 프로그램을 개발하는 경우 나타나는 특징으로 올바르
지 않은 것은?
① 결과적으로 품질에 투입되는 비용이 감소하며 개발 기간이 단축된다.
② 코딩 전까지는 일반적인 개발보다 소요 인력이 더 많이 필요할 수 있다.
③ 초기 프로젝트 비용이 증가하지만, 개발 단계의 재작업과 투입 인력이 감소한다.
④ 코딩이 시작되면서 투입 인력 수요가 급증하고 테스팅 단계에서 최고치가 된다.

해설 :
④ 인스펙션을 적용하지 않은 일반적인 개발에서 코딩이 시작되면서 투입 인력 수요가 급증하며, 테스
팅 단계에서 절정을 이루게 된다.

--

정답 09 ① 10 ④
