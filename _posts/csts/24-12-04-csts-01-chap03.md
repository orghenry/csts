# 제 3 장 소프트웨어 개발 단계와 테스트

--

## 3.1 개요

소프트웨어 테스트는 다양한 방법으로 분류할 수 있습니다. (표 3.1 참조)

- **테스트 레벨에 따른 분류**
- **테스트 설계 방식에 따른 분류**
- **테스트 유형(품질 특성)에 따른 분류**

--

## 소프트웨어 테스트의 분류

![표 3.1 소프트웨어 테스트의 분류](csts/images/csts_table_3.1.png)  
![표 3.1 소프트웨어 테스트의 분류](csts/images/csts_table_3.1-1.png)

--

## 테스트 레벨에 따른 테스트 방법

이 장에서는 **테스트 레벨**에 따른 테스트 방법에 대해 설명합니다.

- **컴포넌트(단위) 테스트**  
- **통합 테스트**
- **시스템 테스트**
- **인수 테스트**

각각의 테스트는 목적과 방법이 다르므로 상세히 알아볼 필요가 있습니다.

--

## 테스트 레벨과 테스트 대상

![그림 3.1 테스트 레벨과 테스트 대상](csts/images/csts_3.1.png)


--


## 컴포넌트 테스트, 통합 테스트, 시스템 테스트

이 그림에서 **CSCI, CSC, CSU**는 시스템을 구성하는 주요 컴포넌트를 나타냅니다. 시스템은 컴포넌트 간의 연동으로 동작하며, 각 컴포넌트 간의 연동은 화살표로 표시됩니다. 예를 들어, **CSCI** 컴포넌트는 **CSC01**, **CSC02**, **CSC03** 컴포넌트를 호출합니다.

--

## 테스트 대상 결정

시스템이 구성되면 이를 바탕으로 컴포넌트 테스트, 통합 테스트, 그리고 시스템 테스트의 대상을 결정할 수 있습니다. (이 구조도는 **아키텍처 설계도**라고 불립니다.) 따라서 시스템에 대한 테스트 레벨과 테스트 대상을 결정하기 전에 시스템의 구조를 먼저 알아야 합니다.

--

## 테스트 레벨별 테스트 대상

- **컴포넌트 테스트**  
  - 각 개별 컴포넌트가 테스트 대상이 됩니다.
  - **테스트 대상 수**: 10개
  
- **통합 테스트**  
  - 화살표로 표시된 연동 관계가 있는 컴포넌트 간의 연결이 테스트 대상이 됩니다.
  - **테스트 대상 수**: 9개
  
- **시스템 테스트**  
  - 전체 시스템 자체가 테스트 대상이 됩니다.
  - **테스트 대상 수**: 1개

--

## 테스트 레벨별 테스트 대상 예시

![표 3.2 테스트 레벨별 테스트 대상 예](csts/images/csts_table_3.2.png)

--

# 3.2 컴포넌트 테스트

--

## 3.2.1 개요

**컴포넌트(단위) 테스트**는 개별 모듈(또는 컴포넌트)을 테스트하는 것으로, 구현 단계에서 각 모듈을 구현한 후 수행됩니다. 물론, **테스트 주도 개발(TDD)**처럼 코드가 개발되기 전에 테스트 케이스를 먼저 생성할 수도 있습니다.

--

### 테스트 환경

개별 모듈에 대해 컴포넌트 테스트를 수행하려면 **모듈을 단독으로 실행할 수 있는 환경**이 필요합니다. 이를 **테스트 베드(Test bed)**라고 하며, 주요 구성 요소는 **테스트 드라이버(Driver)**와 **테스트 스텁(Stub)**입니다.

--

### 그림 3.2: 컴포넌트 테스트를 위한 테스트 환경

![그림 3.2 컴포넌트 테스트를 위한 테스트 환경](csts/images/csts_3.2.png)

--

### 테스트 드라이버와 스텁

컴포넌트 테스트는 시스템을 구성하는 컴포넌트를 **독립적인 방식으로 테스트**하는 것이 특징입니다. 예를 들어, **컴포넌트 0**을 테스트할 때 **컴포넌트 1** 및 **컴포넌트 2**에 의존하지 않도록 테스트를 수행합니다.

- **컴포넌트 0**을 테스트할 때는 **컴포넌트 1**을 호출하는 대신 **스텁**을 사용하여 독립적인 테스트가 이루어집니다.
- 마찬가지로 **컴포넌트 1**을 테스트할 때는 **컴포넌트 2** 대신 **스텁**을 사용합니다.

이러한 방식으로 **개별적인 컴포넌트의 독립적인 동작**을 확인할 수 있습니다.

--

# 3.2.2 모의 객체 생성 프레임워크

--

객체 지향 프로그램에서 **컴포넌트 테스트**를 수행할 때, 테스트 대상인 메소드가 다른 클래스의 객체에 의존하는 경우가 있습니다. 이럴 경우, 해당 메소드를 고립화하여 테스트하는 것이 불가능합니다. 이를 해결하기 위해서는 **절차 지향적 프로그래밍**에서 사용되는 **스텁**과 같은 개념이 필요합니다. 

--

### 모의 객체(Mock Object)

**모의(Mock) 객체**는 **스텁**의 객체 지향 버전이라 할 수 있습니다. 모의 객체는 테스트에서 의존성을 대체하며, 실제 객체 대신 호출되어 **독립적인 컴포넌트 테스트**를 가능하게 합니다.

--

### 모의 객체 생성

모의 객체는 개발자가 처음부터 수작업으로 만들 수도 있고, **모의 객체 생성 프레임워크**를 사용하여 생성할 수도 있습니다. 여기에서는 **Mockito** 모의 객체 생성 프레임워크를 사용하여 **모의 객체**를 만들고, 이를 통해 컴포넌트 테스트를 수행하는 방법을 살펴봅니다.

--

### 예시

예를 들어, 인자로 **은행의 계좌 정보(Account 객체)**를 사용하는 클래스 **Foo**의 **perform()** 메소드를 테스트하는 상황을 고려해봅니다. 이때 **Account** 인터페이스는 그림 3.3과 같이 정의될 수 있습니다.

--

![그림 3.3 Account 인터페이스](csts/images/csts_3.3.png)


--
### 예시: `perform()` 메소드 테스트

**`perform()` 메소드**를 실행하는 데 **500달러**가 소요된다고 가정하면, **은행 잔고**는 최소 **500달러 이상**이어야 합니다. 실제 **계좌(Account)** 객체는 은행과 네트워크로 통신하여 인터페이스에 정의된 기능을 수행해야 하지만, **모의 객체**를 사용하면 실 객체를 대신하여 여러 상황을 간단하게 테스트할 수 있습니다.

--

### JUnit 테스트 케이스

그림 3.4는 `perform()` 메소드가 정상적으로 동작하는 시나리오를 고려하여 작성한 **JUnit 테스트 케이스**입니다. 

--

![그림 3.4 모의 객체를 이용한 JUnit 테스트 케이스](csts/images/csts_3.4.png)

--

## 테스트 케이스 구성

--

### 1. 생성 (Setup)
테스트 케이스는 크게 **생성**, **동작**, **확인** 세 부분으로 구성됩니다.

- **생성** 부분은 테스트에 필요한 상황을 생성하는 부분이며, **Fixture**라고도 불립니다. 이 단계에서는 테스트에 필요한 객체를 생성하거나 자원을 할당합니다. 

#### 예시:
- **1번 문장**에서는 **테스트 대상 객체**와 **계좌 모의 객체**(AcctMock)를 생성합니다.
- **2번 문장**에서는 모의 객체(AcctMock)의 행위를 지정합니다. 예를 들어, `balance()` 메소드가 호출되면 **850달러**를 반환하도록 설정합니다.

--

### 2. 동작 (Action)
- **동작** 부분은 실제로 테스트하고자 하는 기능을 호출하는 부분입니다.
- **3번 문장**에서는 **Foo 클래스의 `perform()` 메소드**를 호출합니다. 이 부분이 실제 테스트 대상의 동작을 실행하는 부분입니다.

--

### 3. 확인 (Verification)
- **확인** 부분은 동작의 실행 결과와 기대 결과를 비교하는 부분입니다. 이 단계가 빠지면 테스트 케이스의 역할을 전혀 할 수 없습니다.
  
#### 예시:
- **4번, 5번 문장**에서는 **`perform()` 메소드 실행 후의 결과**와 예상된 결과를 비교합니다.
- `perform()` 메소드 실행 후, **계좌 객체의 `balance()`** 메소드가 호출되고, 그 후 **예금 인출**이 이루어져야 하므로 **`withdraw()`** 메소드가 호출되어야 합니다. 
- **만약 예상된 함수 호출이 이루어지지 않으면**, 이는 결함으로 간주됩니다.

- 위의 테스트 케이스에서는 각 단계가 명확하게 정의되어 있어, 테스트가 정상적으로 수행되었는지 검증할 수 있습니다.


--

### 심화 노트: 모의 객체

모의 객체는 다음과 같이 분류하기도 한다.

- **더미(Dummy) 객체**  
  테스트할 때 객체만 필요하고 해당 객체의 기능까지는 필요하지 않은 경우에 사용된다. 더미 객체의 메소드가 호출되면 정상 동작은 수행하지 않고 예외를 던진다.

- **테스트 스텁(Stub)**  
  더미 객체에 단순한 기능성을 추가하여, 추가 객체의 특정 상태를 가정하고 특정한 값을 리턴하거나 특정한 메시지를 출력하게 한다.

- **테스트 스파이(Spy)**  
  주로 테스트 대상 클래스(CUT)와 협력하는 클래스로 가는 출력을 검증하는 데 사용된다. CUT가 실행되는 동안 특정 협력 클래스로의 호출(또는 호출의 결과)을 잡아내어, 실행이 끝난 후 정상 호출되었는지 검사한다.

- **가짜(Fake) 객체**  
  실제 협력 클래스의 기능을 대체해야 할 경우에 사용된다. 실제 협력 클래스의 기능 중 일부 또는 전체를 훨씬 단순하게 구현한다. 실제 협력 클래스가 구현되지 않았거나 너무 느리거나, 테스트 환경에서 사용할 수 없을 때 가짜 객체를 사용한다.

모의 객체는 앞서 기술한 모든 형태를 포함하는 의미로 사용된다.

--

### 3.2.3 FIRST 원칙

컴포넌트 테스트를 잘 수행하는 것은 매우 중요하다. 컴포넌트 테스트는 통합 테스트나 시스템 테스트, 인수 테스트보다 쉽게 수행할 수 있으며 테스트 수행에 따른 피드백이 빠르다. 또한, 결함이 발견되었을 때 결함을 발생시키는 부분을 쉽게 식별하여 수정할 수 있으므로 컴포넌트 테스트 케이스를 잘 설계하고 수행해야 한다. 컴포넌트 테스트를 잘 수행하기 위한 **FIRST 원칙**이 있다. 이 원칙은 다음과 같은 5가지 원칙으로 구성되어 있다.

- **Fast**: 컴포넌트 테스트는 빠르게 수행되어야 한다. 이 원칙은 매우 중요하다. 예를 들면, 500개의 컴포넌트 테스트가 있을 때 각 테스트가 실행되는 데 0.5초가 걸린다면 컴포넌트 테스트 모두를 수행하는 데 약 4분이 넘게 소요된다. 컴포넌트 테스트의 주요 목적 중 하나는 리그레션 테스트인데, 코드를 변경할 때마다 4분 넘는 테스트가 수행된다면 개발자는 테스트를 수행하지 않고자 하는 유혹에 빠질 수 있고, 코드에 새로운 기능이 추가될수록 테스트 실행 시간은 증가할 것이다. 결국, 이는 코드의 품질에 심각한 영향을 미칠 수 있다. 특히 데이터베이스나 네트워크처럼 외부 자원에 의존하는 경우에는 테스트 수행 시간이 길어질 가능성이 크다. 이 경우, 모의 객체 생성 프레임워크를 이용하여 테스트 시간을 단축하는 것이 좋다.

- **Isolated**: 컴포넌트 테스트가 다른 컴포넌트 테스트에 의존하지 않도록 해야 한다. 어떤 특정한 컴포넌트 테스트 집합이나 컴포넌트 테스트 하나를 독립적으로 수행할 수 있어야 한다. 만약, 한 컴포넌트 테스트가 다른 컴포넌트 테스트의 수행 결과에 의존한다면 테스트 실행 순서에 따라 다른 결과가 나올 것이다. 즉, 전체 컴포넌트 테스트 집합을 실행한 결과와 개별적으로 컴포넌트 테스트를 실행한 결과가 달라서는 안 된다.

- **Repeatable**: 테스트를 몇 번 실행해도 동일한 결과가 나오도록 해야 한다. 만약 테스트를 실행할 때마다 다른 결과가 나온다면 더 이상 테스트 결과를 신뢰하지 않게 되어 테스트를 수행하지 않게 될 것이다. 이 문제는 테스트가 랜덤 함수나 시간 또는 날짜에 의존하는 경우에 발생할 수 있다. 또한, 데이터베이스를 사용하여 테스트를 하는 경우도 주의해야 한다. 만약, 데이터베이스의 내용이 이미 다른 개발자가 수행한 테스트에 의해 변경되었을 때 이 변경으로 인해 테스트의 결과가 달라질 수 있다. 개발자 자신만이 사용할 수 있는 샌드박스를 구축하여 테스트를 수행하는 것이 좋다.

- **Self-Validating**: 사람의 개입 없이 테스트가 통과되었는지 알 수 있도록 작성해야 한다. 테스트 결과를 판단하기 위해 사람이 개입하도록 작성하면 매우 많은 시간이 소요될 여지가 있고 많은 위험이 따른다. 또한, 테스트에 필요한 데이터 준비 작업이나 설정 파일 조작과 같은 작업도 자동화하여 사람이 개입할 필요가 없는 것이 좋다.

- **Timely**: 컴포넌트 테스트는 제때 수행되어야 한다. 여기서 제때란 테스트 대상이 되는 코드가 작성되는 시점을 의미한다. TDD에서는 코드 작성 바로 전이다.


--
### 3.3 통합 테스트

#### 3.3.1 개요

통합(Integration) 테스트는 컴포넌트를 통합하는 과정에서 수행되는 테스트이다. 컴포넌트 테스트는 개별적인 모듈⋅컴포넌트의 기능이 올바르게 작동하는지 테스트하는 반면에 통합 테스트는 컴포넌트 간의 상호 연동이 제대로 수행되는지 검사하는 테스트이다. 개별적인 컴포넌트에 대해 테스트가 수행되었더라도 실제로 컴포넌트들을 통합한 후에 결함이 발생할 수 있다.

통합 테스트에서는 서로 다른 컴포넌트가 통합되어 호출된다. 그림 3.5는 3개의 컴포넌트에 대한 통합 테스트 방법을 나타낸 것이다. (a)에서는 컴포넌트 1과 컴포넌트 2를, (b)에서는 3개의 컴포넌트를 모두 통합한 모습을 보여준다.

![그림 3.5 통합 테스트](csts/images/csts_3.5.png)

통합 테스트를 수행할 때는 각 테스트별로 통합 대상이 되는 컴포넌트가 먼저 결정되어야 한다. 예를 들어, 그림 3.5의 (a)에서는 컴포넌트 1과 컴포넌트 2가 통합 대상이고, 그림 3.5의 (b)에서는 컴포넌트 0, 컴포넌트 1, 컴포넌트 2가 통합 대상이 된다.

--
# 통합 테스트: 상호작용에 초점을 둔 테스트

--

### 통합 테스트 목적
- **연결 정확성**에 초점을 두는 경우
- **기능적 측면**에 초점을 두는 경우

--

### 상호작용에 초점을 둔 통합 테스트 예시

- **테스트 대상**: 컴포넌트 1과 컴포넌트 2
- **목표**: 두 컴포넌트 간의 데이터 전달 적합성 검사
  - 데이터 누락, 변경, 순서 변경 확인

![그림 3.6  상호작용에 초점을 둔 통합 테스트](csts/images/csts_3.6.png)

--

### 데이터 로그 비교

- **Output1 (컴포넌트 1)**: 전송 데이터 로그 생성
- **Input2 (컴포넌트 2)**: 수신 데이터 로그 생성
- **검증 방법**: 두 로그 값을 비교하여 상호작용 적합성 확인

--

### 로그 생성 문제

- **문제**: 임베디드 소프트웨어에서 로그 크기 제한
- **해결**: 
  - 핑거 프린트(Fingerprint) 사용
  - 데이터 변경 여부 판단을 위한 최소한의 로그 생성

--# 통합 테스트: 기능에 초점을 둔 테스트

--

### 통합 테스트 목적
- **상호작용 초점**: 데이터 전송 적합성
- **기능 초점**: 연결된 두 컴포넌트의 기능적 적합성 확인

--

### 기능 초점의 통합 테스트 예시

- **테스트 대상**: 컴포넌트 1과 컴포넌트 2 전체
- **목표**: 두 컴포넌트의 전체적인 기능적 적합성 검사
  - **컴포넌트 1**과 **컴포넌트 2**의 종합적인 동작 결과 확인

![그림 3.7  기능에 초점을 둔 통합 테스트](csts/images/csts_3.7.png)

--

### 컴포넌트 테스트 vs 통합 테스트

- **컴포넌트 테스트**: 
  - 컴포넌트 1만 테스트
  - 컴포넌트 2는 스텁을 사용하여 대체
- **통합 테스트**: 
  - 실제 컴포넌트 2와 컴포넌트 1을 연결하여 종합적으로 테스트

--

### 관점에 따른 선택

- **상호작용 초점**: 연결에서 오작동 가능성이 클 때
- **기능 초점**: 연결에 문제가 적을 때, 전체적인 기능을 테스트

--
# 점진적 통합

--

### 점진적 통합과 빅뱅 방식
- **빅뱅(Big-bang) 방식**: 
  - 모든 컴포넌트를 한 번에 통합하여 테스트
  - 문제 발생 시, 원인 컴포넌트를 찾기 어려움
  - 예: 그림 3.5 (b)에서 컴포넌트 3개를 한 번에 통합한 경우

--

### 빅뱅 방식의 문제점
- 많은 수의 컴포넌트를 한 번에 통합하면, 결함을 가진 컴포넌트를 찾기가 어려움
- 예: 30개 컴포넌트를 통합했을 때, 결함 원인 파악이 어려움

--

### 점진적 방식의 적용
- **점진적(Incremental) 통합**: 
  - 적은 수의 컴포넌트를 차례로 통합하여 테스트
  - 오동작의 원인을 쉽게 찾을 수 있음
  - 테스트 드라이버 및 스텁을 여러 번 개발해야 함

--

### 점진적 통합 예시
1. **1차 통합 테스트**: 컴포넌트 1과 컴포넌트 2 통합
2. **2차 통합 테스트**: 컴포넌트 0 추가 후, 전체 3개의 컴포넌트 통합

--

# 점진적 통합 테스트 수행 방식

--

### 점진적 통합 방법 종류
1. **상향식 통합 (Bottom-up Integration)**:
   - 하위 컴포넌트부터 통합하여 상위 컴포넌트를 통합
   - 시스템 내에서 하위 컴포넌트들이 먼저 결합되고, 상위 컴포넌트를 점진적으로 추가함

2. **하향식 통합 (Top-down Integration)**:
   - 상위 컴포넌트부터 통합하여 하위 컴포넌트를 통합
   - 시스템 내에서 가장 상위 컴포넌트부터 통합되고, 하위 컴포넌트들이 점진적으로 추가됨

3. **샌드위치 통합 (Sandwich Integration)**:
   - 상향식 통합과 하향식 통합을 결합하여 상위와 하위 컴포넌트를 동시에 통합
   - 중간 컴포넌트를 두고 상위와 하위 컴포넌트를 모두 통합

--

### 상향식과 하향식 통합의 차이
- **상향식 통합**: 하위 컴포넌트들을 먼저 통합하고, 점차 상위 컴포넌트를 통합
- **하향식 통합**: 상위 컴포넌트부터 시작하여 점진적으로 하위 컴포넌트를 통합

--

### 그림 3.8: 상향식 통합과 하향식 통합
![그림 3.8  점진적 통합 순서：상향식과 하향식](csts/images/csts_3.8.png)

--
# 상향식 통합 테스트 및 하향식 통합 테스트

--

### 통합 방식에 따른 컴포넌트 선택

- **상향식 통합**과 **하향식 통합**은 선택되는 컴포넌트 순서가 다릅니다. 
- **상향식 통합**에서는 하위 컴포넌트를 먼저 통합하고, 그 후 상위 컴포넌트를 통합합니다.
- **하향식 통합**에서는 상위 컴포넌트를 먼저 통합하고, 그 후 하위 컴포넌트를 점진적으로 추가합니다.

--

### 표 3.3: 상향식 통합과 하향식 통합의 예
![표 3.3  상향식 통합과 하향식 통합의 예](csts/images/csts_table_3.9.png)

--

### 상향식 통합 과정

1. **하위 컴포넌트 식별 및 그룹화**:
   - 특수한 기능을 제공하는 하위 컴포넌트를 식별하여 그룹화하거나 클러스터링합니다.
   
2. **테스트 드라이버 작성**:
   - 하위 컴포넌트 그룹에 대해 테스트 드라이버를 작성하여 테스트를 수행합니다.

3. **클러스터 테스트**:
   - 여러 모듈을 묶은 '클러스터' 또는 '빌드'를 테스트합니다.

4. **실제 모듈 결합**:
   - 테스트 후 테스트 드라이버를 제거하고 실제 모듈을 결합합니다.

5. **반복**:
   - 시스템이 완전히 통합될 때까지 이 과정을 반복합니다.

--

### 그림 3.9: 상향식 통합 테스트
![그림 3.9  상향식 통합 테스트](csts/images/csts_3.9.png)

--
# 상향식 통합 테스트와 하향식 통합 테스트의 장점 및 과정

--

### 상향식 통합 테스트의 장점

- **하위 컴포넌트 충분히 테스트**:
  - 상향식 통합 테스트는 하위 컴포넌트를 충분히 테스트할 수 있습니다.
  - 하위 컴포넌트는 시스템에서 공통적인 기능을 제공하는 역할을 하며, 시스템이 진행될수록 상위 컴포넌트가 자주 호출하는 코드가 많아집니다.
  - 이러한 코드는 빈번하게 테스트되므로, 오류를 조기에 발견할 수 있습니다.
  
- **테스트 스텁 비용 절감**:
  - 하향식 통합에서 필요한 테스트 스텁을 제공하는 비용이 발생하지 않으며, 하위 컴포넌트가 먼저 테스트됩니다.

--

### 하향식 통합 테스트 방식

1. **상위 컴포넌트 테스트**:
   - 가장 상위에 있는 컴포넌트를 먼저 테스트하고, 하위 컴포넌트는 테스트 스텁으로 대치합니다.

2. **테스트 스텁 교체**:
   - **깊이 우선 방식**이나 **너비 우선 방식**을 사용하여 테스트 스텁을 하나씩 실제 컴포넌트로 대치합니다.

3. **하위 컴포넌트 대체**:
   - 대치된 컴포넌트가 실제로 호출하는 하위 컴포넌트는 여전히 테스트 스텁으로 대치된 상태입니다.

4. **리그레션 테스트**:
   - 테스트 스텁이 실제 모듈로 대체되면 시스템에 변경이 발생하므로 리그레션 테스트를 수행합니다.

5. **반복**:
   - 시스템이 완전히 통합될 때까지 이 과정을 반복합니다.

--

### 그림 3.10: 하향식 통합 테스팅 과정
![그림 3.10  하향식 통합 테스팅 과정](csts/images/csts_3.10.png)

--
# 샌드위치 통합 테스트 방식

--

### 컴포넌트 종속 관계

- **상위 컴포넌트**:
  - 시스템의 기능을 결정합니다.
  - 결함이 발생하면 시스템 설계의 문제로 해석될 수 있습니다.
  - 하향식 통합 테스트 방식으로 빠르게 발견될 수 있습니다.

- **하위 컴포넌트**:
  - 시스템이 제공하는 기능을 보조합니다.
  - 결함이 발생하면 기능 구현의 문제로 간주될 수 있습니다.

### 상향식과 하향식 통합의 결합: 샌드위치 통합

- **샌드위치 통합 테스트**:
  - 상향식과 하향식 통합 테스트 방식을 결합한 전략입니다.
  - 하위 컴포넌트는 상향식 방식으로 통합하고, 상위 컴포넌트는 하향식 방식으로 통합합니다.

--

### 샌드위치 통합 과정

1. **상위 컴포넌트 M1**:
   - 테스트 스텁 M2, M3, M4를 사용하여 테스트합니다.
   
2. **하위 컴포넌트 M5, M6, M7**:
   - 이들 컴포넌트를 클러스터링하여 테스트 드라이버 D1을 사용해 테스트합니다.

3. **통합**:
   - **M2**를 실제 컴포넌트로 통합하고, **M3**와 **M4**도 추가하여 시스템을 완성합니다.

--

### 그림 3.11: 샌드위치 통합
![그림 3.11  샌드위치 통합](csts/images/csts_3.11.png)


# 시스템 테스트 및 인수 테스트

--

### 시스템 테스트 (System Test)

- **목적**: 통합 테스트가 완료된 후, 전체 시스템이 시스템 명세에 맞게 개발되었는지 검증합니다.
- **범위**: 
  - **기능 검증**: 시스템이 제대로 작동하는지 확인합니다.
  - **비기능적 요구사항** 검증:
    - 성능 (Performance)
    - 호환성 (Compatibility)
    - 사용성 (Usability)
    - 신뢰성 (Reliability)
    - 보안성 (Security)
    - 유지보수성 (Maintainability)
    - 이식성 (Portability)
  
시스템 테스트는 컴포넌트 테스트나 통합 테스트와 달리, 기능뿐만 아니라 위와 같은 다양한 비기능적 요구사항이 충족되었는지를 확인합니다.

--

### 인수 테스트 (Acceptance Test)

- **목적**: 시스템이 실제 사용자의 요구를 만족하는지 확인하고, 시스템을 인수할 수 있는지를 평가합니다.
- **중점**: 결함 발견보다는 고객의 입장에서 시스템을 인수해도 될지 평가합니다.
- **테스트 케이스**:
  - 사용자나 소프트웨어 구매자가 제시할 수 있습니다.
  - 시스템 테스트에서 사용한 테스트 케이스를 사용할 수 있습니다.
- **차이점**: 실제 사용자가 시스템을 사용하는 방식은 개발자가 테스트한 방식과 다를 수 있으며, 이로 인해 인수 테스트에서 결함이 발견될 수 있습니다.

--

### 인수 테스트 유형

1. **알파 테스트 (Alpha Test)**:
   - 개발자 환경에서 통제된 상태로, 선택된 사용자(회사 내의 다른 사용자 또는 실제 사용자)가 수행합니다.
  
2. **베타 테스트 (Beta Test)**:
   - 일정 수의 사용자에게 소프트웨어를 사용하게 하고 피드백을 받습니다.
   - 보통 베타 테스트에는 개발자가 참여하지 않습니다.

# 리그레션 테스트 (Regression Test)

--

리그레션 테스트는 소프트웨어가 수정된 후, 변경 사항이 올바르게 반영되었는지 확인하는 테스트입니다. 이는 유지보수 단계에서 중요한 활동으로, 소프트웨어 수정을 통해 기존 기능에 의도치 않은 영향을 미쳤는지를 검증하는 데 사용됩니다.

### 유지보수 단계에서 소프트웨어 수정 이유

1. **결함 수정 작업 (Corrective Maintenance)**: 
   - 소프트웨어 사용 중에 발견된 결함을 수정하기 위한 활동.
  
2. **기능 보강 작업 (Perfective Maintenance)**: 
   - 소프트웨어 기능을 추가하거나 성능을 개선하기 위한 활동.
  
3. **적응 작업 (Adaptive Maintenance)**: 
   - 새로운 운영 환경에 소프트웨어 시스템을 적응시키기 위한 활동.
  
4. **예방 작업 (Preventive Maintenance)**: 
   - 시스템 구조를 개선하거나 문서를 준비하여 향후 유지보수를 용이하게 하기 위한 활동.

--

그림 3.12는 소프트웨어 유지보수 활동 비율을 나타냅니다.

![그림 3.12  소프트웨어 유지보수 활동 비율](csts/images/csts_3.12.png)

--

## 리그레션 테스트 사이클

소프트웨어 수정 후 변경 작업으로 인해 새로운 결함이 유발되었는지 확인하는 리그레션 테스트.

![그림 3.13  리그레션 테스트 사이클](csts/images/csts_3.13.png)

--

## 리그레션 테스트 방법

- **개발 단계에서 사용한 테스트 케이스**를 수정된 프로그램에 실행하여, 기존 프로그램과 결과 비교.
- 결과가 다르면 의도된 변화인지 확인.
- 의도하지 않은 결과라면 결함 발생으로 판단.

--

## 리그레션 테스트 시간 변화

시간이 갈수록 시스템에 새로운 기능이 추가됨에 따라, 리그레션 테스트에 소요되는 시간과 비용도 증가.

![표 3.4  기능 추가에 따른 리그레션 테스트 시간 변화](csts/images/csts_table_3.4.png)

--

## 리그레션 테스트 방식

### 1. **Retest-All**
- 모든 기존 테스트 케이스를 사용하는 방식
- 시간과 자원 소모가 많음

### 2. **부분적 테스트 케이스 사용**
- 일부 테스트 케이스만 사용하여 리그레션 테스트를 수행

![그림 3.14  리그레션 테스트 방식](csts/images/csts_3.14.png)

--


## 선택적 리그레션 테스트

기존의 테스트 케이스 중 일부를 선택하여 리그레션 테스트를 수행하는 방식.

- **변경 영향 분석(Change impact analysis)**을 통해 원래 프로그램과 변경된 프로그램에서 출력 결과에 영향을 미칠 수 있는 테스트 케이스를 식별.
- **슬라이싱 기법**을 활용하여, 테스트 케이스가 실행한 문장들이 변경된 부분을 포함하는지 파악하고, 포함되면 해당 테스트 케이스를 리그레션 테스트 케이스로 선택.

--

## 테스트 최소화 방식

- 중복된 테스트 케이스를 제거하여 테스트 케이스 수를 줄이는 방식.
- **커버리지** 개념을 이용해 중복된 테스트를 제거.
- 단, 중복 제거로 인해 중요한 테스트 케이스가 빠질 수 있어 주의가 필요.

--

## 테스트 우선순위화 방식

- 테스트 케이스에 우선순위를 부여하여, 우선순위가 높은 테스트 케이스만 실행.
- **APFD(Average Percentage of Faults Detected)** 척도를 사용하여 우선순위화 효과 평가.

--

## APFD (Average Percentage of Faults Detected)

- 테스트 케이스의 실행 순서를 결정해 가능한 한 빨리 결함을 찾도록 유도.
- APFD 계산 공식:

![APFD](csts/images/csts_3.apfd.png)

--

Exercise 01
테스트 케이스의 실행 순서에 따라 APFD가 어떻게 변화하는지 살펴보자. 표 3.5는 5개의 테스트 케이스와 이들이 검출한 5개의 결함을 보여준다.

![표 3.5  결함 매트릭스](csts/images/csts_table_3.5.png)

우선 테스트 케이스가 TC1, TC2, TC3, TC4, TC5의 순서대로 실행되었을 때 APFD를 계 산해보자.
n=5, m=5

![Exercise 01](csts/images/csts_3.ex01.png)

예제에서 볼 수 있듯이 테스트 케이스의 실행 순서에 따라 APFD가 큰 차이를 보인다. APF D가 높다는 것은 더 적은 수의 테스트 케이스를 실행하여 많은 결함을 빠르게 검출할 수 있 음을 의미한다. 만약, 리그레션 테스트에 소요되는 시간과 비용이 제한된 상황이라면, 가 능한 한 결함 검출을 빠르게 할 수 있는 테스트 케이스의 우선순위를 높게 설정하여 테스트 의 효용성을 높일 수 있다.
결함 검출률이 높은 테스트 케이스 식별은 현실적으로 매우 어려운 일이다. 보통은 비즈니 스 중요도, 리스크, 테스트 케이스의 실행 시간, 커버리지, 결함 검출 내역 등의 요인들을 고려하여 테스트 케이스 우선순위 등급을 설정한다.
리그레션 테스트는 컴포넌트 테스트, 통합 테스트, 시스템 테스트를 비롯한 모든 단계에서 수행된다. 그림 3.15는 애플리케이션에 변경이 이루어진 후에 수행되는 리그레션 테스트 의 절차를 보여준다. 

![그림 3.15  리그레션 테스트 절차](csts/images/csts_3.15.png)

테스트 유지보수 단계에는 더 이상 필요 없는 테스트 케이스를 제거하는 과정이 있다. 만 약, 어떤 기능이 더 이상 비즈니스에 필요하지 않아 애플리케이션에서 제거되었다면, 이를 테스트하는 테스트 케이스도 리그레션 테스트 케이스 집합에서 제거되어야 한다. 이 경우 에 해당 테스트 케이스를 제거하지 않는다면 이로 인하여 리그레션 테스트를 수행할 때 잘 못된 테스트 결과가 보고되고 테스트의 신뢰성을 잃게 만드는 요인이 될 것이다.
또한, 요구사항이 변경되어 입력 출력의 관계가 변할 수 있다. 이 경우에도 해당하는 테스 트 케이스를 요구사항 변경에 따라 변경하는 작업이 필요하다. 새로 추가된 테스트 케이스 가 있다면 이 테스트 케이스를 자동화하는 작업도 추가될 수 있다. 리그레션 테스트는 많은 테스트 케이스를 자주 실행하므로 가급적 자동화하는 편이 효율적이다. 따라서 새로 추가 된 테스트 케이스를 자동화하는 작업도 중요한 테스트 유지보수 작업에 해당한다.
다음은 리그레션 테스트 프로세스를 수행하는 예이다.

--

Exercise 02
기존에는 일반 택배 서비스만 제공하던 온라인 샵이 이번 릴리즈에서 퀵 서 비스를 제공하는 기능을 추가하였다. 이 경우에 적용되는 리그레션 테스트 프로세스를 살펴보자.

기능 추가 후 배송지 정보를 입력하고 저장하는 퀵서비스 윈도우에 대한 컴포넌트 테스트 를 수행한다. 또한, 택배 서비스 화면에 기존의 택배 서비스와 추가된 퀵 서비스 옵션이 나 타나는지 검증한다. 이때 기존의 택배 서비스 인터페이스 API 서버와 퀵 서비스 인터페이 스 API를 제공하는 서버는 모의 객체로 대신한다.
통합 테스트 단계에서 퀵 서비스 인터페이스 API를 제공하는 서버와 통합하여 적절하게 호출되었는지 검증하고 배송지 정보가 문제없이 전달되었는지 확인한다. 또한, 기존의 택 배 서비스를 대상으로 통합 리그레션 테스트를 수행하여 퀵 서비스 추가가 기존 택배 서비 스에 어떤 영향이 있는지 검증한다.
통합 테스트가 통과된 후에는 GUI를 이용한 퀵 서비스 시스템 테스트를 수행하고, 기존 택 배 서비스에 대해서도 리그레션 테스트를 수행한다. 시간과 비용에 제약이 있다면 테스트 우선순위화 방식을 이용하여 우선순위 등급 1, 2에 대해서만 기존의 택배 서비스에 대한 GUI 테스트를 수행한다. 이 경우에는 비기능적 테스트는 수행하지 않는다.

--

Exercise

01   소프트웨어 개발 단계별 테스트에 대한 설명으로 올바른 것은?
① 단위 테스트: 모듈을 통합하는 과정에 사용되는 인터페이스를 대상으로 상호 작용이 올바 르게 이루어지는지 검증하는 테스트
② 통합 테스트: 개발 시스템이 인수 조건을 만족하는지 검증하는 테스트
③ 시스템 테스트: 시스템이 요구사항에 맞게 개발되었는지 기능 및 비기능 측면을 확인하는 테스트
④ 인수 테스트: 하나의 소프트웨어 단위가 정상적으로 기능을 수행하는지 여부를 확인하는 테스트

해설 : ① 통합테스트에 대한 설명이다.
② 인수테스트에 대한 설명이다.
④ 단위테스트에 대한 설명이다.

--
02 상향식 통합 테스트에 대한 설명으로 가장 올바른 것은?
① 많은 수의 테스트 스텁이 필요하다.
② 설계 오류를 빨리 발견할 수 있다.
③ 하위 컴포넌트가 충분하게 테스트 된다.
④ 빅뱅 통합 방식의 하나이다.

해설 :
①, ② 하향식 통합 테스트에 대한 설명이다.
③ 구조도의 하위 계층에 있는 모듈들을 먼저 테스트하므로 하위 모듈들은 충분하게 테스트 된다. ④ 상향식 통합테스트는 점진적 통합테스트 방식의 하나이다. 

--
03   FIRST 원칙은 통합 테스트를 잘 수행하기 위한 원칙이다. [○/×]
해설 : FIRST 원칙은 단위 테스트를 잘 수행하기 위한 원칙이다. 

--

정답   01 ③  02 ③  03 ×

--

04   다음 중 올바르지 않은 설명은 무엇인가?
① 새로운 기능이 추가되면 이 기능을 테스트하는 테스트 케이스도 추가되어야 한다.
② 기존의 기능이 변경되면 변경된 기능을 테스트하는 테스트 케이스도 변경되어야 한다.
③ 기존의 기능이 제거되면 삭제된 기능을 테스트하는 테스트 케이스는 재사용을 위해 그대 로 둔다.
④ 가능한 동일한 프로그램 경로를 실행하는 테스트 케이스들은 제거하여 중복을 피한다. 

해설 : 
만약, 어떤 기능이 더 이상 비즈니스에 필요하지 않아 애플리케이션에서 제거되었다면, 이를 테스트하 는 테스트 케이스도 리그레션 테스트 케이스 집합에서 제거되어야 한다. 이 경우에 해당 테스트 케이스 를 제거하지 않는다면 이로 인하여 리그레션 테스트를 수행할 때 잘못된 테스트 결과가 보고되고 테스 트의 신뢰성을 잃게 만드는 요인이 된다.

--
05   다음 중에서 APFD에 대한 설명으로 옳지 않은 것은?
① 테스트 케이스 실행 비율 대비 검출된 결함의 비율을 측정한다. 
② APFD가 낮다는 것은 더 적은 수의 테스트 케이스를 실행하여 많은 결함을 빠르게 검출할 수 있다는 것을 의미한다.
③ APFD는 테스트 케이스의 수와 결함의 수, 실행 순서로 계산된다.
④ 리그레션 테스트 케이스의 우선순위를 결정하는 데 사용된다.

해설 : 
APFD가 높다는 것은 더 적은 수의 테스트 케이스를 실행하여 많은 결함을 빠르게 검출할 수 있다는 것을 의미한다.

--
06   결함 수정 후 이 작업이 기존의 기능에 새로운 결함이 도입되었는지 검증하기 위해 리그레션 테스트를 수행해야 한다. [○/×]

해설 : 맞는 설명이다.

--
정답   04 ③  05 ②  06 ○

--

07   테스트와 관련된 다음의 설명 중 올바른 것은?
① 성숙도가 높은 테스트는 결함이 발견된 소프트웨어 모듈을 확인하고, 이를 해결하기 위해 소스 코드를 어떻게 수정해야 하는지 알려준다. 
② 단순한 소스 코드의 철자를 바로잡거나 알고리즘의 부정확한 구현을 정확하게 수정하는 작업을 정적분석이라 한다.
③ 초기에 결함을 검출한 테스트 케이스를 이용하여 다시 테스트하는 것을 스모크테스트라 한다.
④ 유지보수 단계에서 소프트웨어가 수정된 후, 기존 프로그램이 변경된 부분으로 인해 영향 을 받지 않았는지 검사하기 위한 테스트를 회귀(Regression) 테스트라 한다. 

해설 :   ①과 ②는 디버깅, ③ 스모크테스트는 빌드가 테스트할 수준인지 확인하는 테스트이다. 

--

08   아래의 시스템 구성 모듈을 너비 우선(Breadth-First) 방식으로 하향식 통합하였을 때, 통합된 순서는 M1, M2, M3, M4, M5, M6, M7, M8 이다. [○/×]

![해설 08](csts/images/csts_3.ex08.png)

--
09   다음 설명에 적절한 테스트 용어를 기재하시오.
테스트가 가능한 최소 단위의 소프트웨어(모듈, 프로그램, 객체, 클래스 등) 내에서 결함을 찾 고 검증하는 테스트 단계

--
10   인수 테스트의 일반적인 수행 주체는 누구인가?

① 개발자
② 테스트 팀
③ 시스템 엔지니어
④ 고객 또는 사용자

해설 : 인수 테스트는 고객 또는 사용자에 의해 행해진다.

--
정답   07 ④  08 ○  09 단위 테스트(unit test), 단위 테스팅(unit testing)  10 ④

